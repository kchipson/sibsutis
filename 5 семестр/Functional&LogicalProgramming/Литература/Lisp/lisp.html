<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Справочник по стандартным функциям  AutoLISP</TITLE>
<link REL="stylesheet" HREF="./olya.css" TYPE="text/css">
</HEAD>
<BODY BGCOLOR=WHITE  LINK=BLUE VLINK=PURPLE  ALINK=RED>
<h1 align="center">Справочник по стандартным функциям AUTOLISP</h1>
<p><B><FONT FACE="Arial" SIZE=4> </font></B><FONT FACE="Times New Roman" > <img src="./pic/tick_green_2.gif" width="20" height="16"><A HREF="#1"><font size="+1">Функции 
  AutoLISPа</font></A></FONT></p>
<blockquote> 
  <blockquote> 
    <p><img src="./pic/diamond_green_1.gif" width="20" height="16"><a href ="#mat_f">Математические 
      функции</a></p>
    <p><img src="./pic/diamond_green_1.gif" width="20" height="16"><font color="#006666"><b>Алфавитный 
      список</b></font> <a href = "#a"> A</a> <a href="#b">B</a> <a href="#c"> 
      C</a> <a href="#d">D</a> <a href="#e">E</a> <a href="#f"> F</a> <a href="#g">G</a> 
      <a href="#i">I</a> <a href="#_LL">L</a> <a href="#m">M</a> <a href="#n">N</a> 
      <a href="#O">O</a> <a href="#p">P</a> <a href="#q">Q</a> <a href="#r">R</a> 
      <a href="#s">S</a> <a href="#t">T</a> <a href="#u">U</a> <a href="#v">V</a> 
      <a href="#w">W</a> <a href="#z">Z</a></p>
  </blockquote>
</blockquote>
<p><FONT FACE="Times New Roman" ><img src="./pic/tick_green_2.gif" width="20" height="16"><A HREF="#2"><font size="+1">Примитивы 
  и механизмы доступа</font></A> </FONT></p>
<FONT FACE="Times New Roman" > 
<P ALIGN="JUSTIFY"><img src="./pic/tick_green_2.gif" width="20" height="16"><A HREF="#3"><font size="+1">Сообщения 
  об ошибках</font></A></P>
<P ALIGN="JUSTIFY"><img src="./pic/birds_3.gif" width="560" height="47"></P>
</FONT> 
<p><FONT FACE="Times New Roman" > </FONT></p>
<FONT FACE="Times New Roman" ><P ALIGN="JUSTIFY"><A NAME="#1"></A></P>
</FONT>
<p><A NAME="#1"><a name = "#mat_f"></a><a name = "#mat_f"><A HREF="#_Toc465260871">(+ 
  &lt;число&gt; &lt;число&gt;...)</A></a></A> 
<p><A HREF="#_Toc465260872"> (- &lt;число&gt; &lt;число&gt;...)</A></p>
<p><A HREF="#_Toc465260873"> (* &lt;число&gt; &lt;число&gt;...)</A></P>
<P><A HREF="#_Toc465260874">(/ &lt;число&gt; &lt;число&gt;...)</A></P>
<P><A HREF="#_Toc465260875">(= &lt;атом&gt; &lt;атом&gt;...)</A></P>
<P><A HREF="#_Toc465260876">(/=  &lt;атом1&gt; &lt;атом2&gt;)</A></P>
<P><A HREF="#_Toc465260877">(&lt; &lt;атом&gt; &lt;атом&gt;...)</A></P>
<P><A HREF="#_Toc465260878">(&lt;= &lt;атом&gt; &lt;атом&gt;...)</A></P>
<P><A HREF="#_Toc465260879">(&gt; &lt;атом&gt; &lt;атом&gt;...)</A></P>
<P><A HREF="#_Toc465260880">(&gt;= &lt;атом&gt; &lt;атом&gt;...)</A></P>
<P><A HREF="#_Toc465260881">(~ &lt;число&gt;)</A></P>
<P><A HREF="#_Toc465260882"> (1+ &lt;число&gt;)</A></P>
<P><A HREF="#_Toc465260883"> (1- &lt;число&gt;)</A></P>
<P>&nbsp;</P>

<P><a name="#a"><A HREF="#_Toc465260884">(abs &lt;число&gt;)</A></a></P>
<P><A HREF="#_Toc465260885">(and &lt;выражение&gt;...)</A></P>
<P><A HREF="#_Toc465260886">(angle &lt;точ1&gt; &lt;точ2&gt;)</A></P>
<P><A HREF="#_Toc465260887"> (angtos &lt;угол&gt; [&lt;представление&gt; [&lt;точность&gt;]])</A></P>
<P><A HREF="#_Toc465260888"> (append &lt;выражение&gt;...)</A></P>
<P><A HREF="#_Toc465260889"> (apply &lt;функция&gt; &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260890"> (ascii &lt;строковая константа&gt;)</A></P>
<P><A HREF="#_Toc465260891"> (assoc &lt;элемент списка&gt; &lt;структурированный список&gt;)</A></P>
<P><A HREF="#_Toc465260892"> (atan &lt;число1&gt; [&lt;число2&gt;])</A></P>
<P><A HREF="#_Toc465260893"> (atof &lt;строковая константа&gt;)</A></P>
<P><A HREF="#_Toc465260894"> (atoi &lt;строковая константа&gt; )</A></P>
<P><A HREF="#_Toc465260895"> (atom &lt;элемент&gt;)</A></P>
<P>&nbsp;</P>

<P><a name = "#b"><A HREF="#_Toc465260896">  (Boole &lt;функция&gt; &lt;целое1&gt; &lt;целое2&gt;...)</A></A></P>
<P><A HREF="#_Toc465260897"> (boundp &lt;атом&gt;)</A></P>
<P>&nbsp;</P>

<P><a name="#c"><A HREF="#_Toc465260899"> (car &lt;список&gt;)</A></a></P>
<P><A HREF="#_Toc465260900"> (cdr &lt;список&gt; )</A></P>
 <P><A HREF="#_Toc465260901">(chr &lt;число&gt;)</A></P>
<P ><A HREF="#_Toc465260902">(close &lt;описатель файла&gt;)</A></P>
<P><A HREF="#_Toc465260903"> (command &lt;аргумент&gt;...)</A></P>
<P><A HREF="#_Toc465260904">Прерывание  для ввода информации пользователем</A></P>
<p><A HREF="#_Toc465260905"> (cond (&lt;тест1&gt; &lt;результат&gt;...)...)</A></P>
<P><A HREF="#_Toc465260906"> (CONS &lt;новый первый элемент&gt; &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260907"> (cos &lt;угол&gt;)</A></P>
<P>&nbsp;</P>

<P><a name="#d"><A HREF="#_Toc465260908"> (defun &lt;символ&gt; &lt;список аргументов&gt; &lt;выражение&gt;...)</A></A></P>
<P><A HREF="#_Toc465260911"> (distance &lt;точка1&gt; &lt;точка2&gt;)</A></P>
<P>&nbsp;</P>

<P><a name="#e"><A HREF="#_Toc465260912"> (eq &lt;выражение1&gt; &lt;выражение2&gt;)</A></A></P>
<P><A HREF="#_Toc465260913"> (equal &lt;выражение1&gt; &lt;выражение2&gt;)</A></P>
<P><A HREF="#_Toc465260914"> (eval &lt;выражение&gt;)</A></P>
<P><A HREF="#_Toc465260915"> (exp &lt;число&gt;)</A></P>
<P ><A HREF="#_Toc465260916"> (expt &lt;основание&gt; &lt;степень&gt;)</A></P>
<P ><A HREF="#_Toc465260995"> (*error* &lt;строка&gt;)</A></P>
<P >&nbsp;</P>

<P ><a name="#f"><A HREF="#_Toc465260917"> (fix &lt;число&gt;)</A></A></P>
<P><A HREF="#_Toc465260918"> (float &lt;число&gt;)</A></P>
<P><A HREF="#_Toc465260919"> (foreach &lt;имя&gt; &lt;список&gt; &lt;выражение&gt;...)</A></P>
<P>&nbsp;</P>

<P ><a name="#g"><A HREF="#_Toc465260920"> (gcd &lt;число1&gt; &lt;число2&gt;)</A></A></P>
<P><A HREF="#_Toc465260921"> (getangle [&lt;точка&gt;] [&lt;подсказка&gt;])</A></P>
<P><A HREF="#_Toc465260922"> (getcorner &lt;точка&gt; [&lt;подсказка&gt;])</A></P>
<P ><A HREF="#_Toc465260923"> (getdist [&lt;точка&gt;] [&lt;подсказка&gt;])</A></P>
<P><A HREF="#_Toc465260924"> (getint [&lt;подсказка&gt;])</A></P>
<P><A HREF="#_Toc465260925">  (getkword [&lt;подсказка&gt;])</A></P>
<P><A HREF="#_Toc465260926"> (getorient [&lt;точка&gt;] [&lt;подсказка&gt;])</A></P>
<P><A HREF="#_Toc465260927"> (getpoint [&lt;точка&gt;] [&lt;подсказка&gt;])</A></P>
<P ><A HREF="#_Toc465260928"> (getreal [&lt;подсказка&gt;])</A></P>
<P><A HREF="#_Toc465260929">  (getstring [&lt;cr&gt;] [&lt;подсказка&gt;])</A></P>
<P ><A HREF="#_Toc465260930"> (getvar &lt;имя переменной&gt;)</A></P>
<P><A HREF="#_Toc465260931">(graphscr)</A></P>
<P>&nbsp;</P>

<P><a name="#i"><A HREF="#_Toc465260932"> (if &lt;текст-выражение&gt; &lt;выражение-тогда&gt; [&lt;выражение-иначе&gt;])</A></A></P>
<P ><A HREF="#_Toc465260933">(initget [&lt;биты&gt;] [&lt;строка&gt;])</A></P>
<P ><A HREF="#_Toc465260934">(insers &lt;точка1&gt; &lt;точка2&gt; &lt;точка3&gt; &lt;точка4&gt; [&lt;onseg&gt;])</A></P>
<P><A HREF="#_Toc465260935"> (itoa &lt;целое&gt;)</A></P>
<P>&nbsp;</P>

<P><a name="#_LL"> <A HREF="#_Toc465260936"> (lambda &lt;аргументы&gt; &lt;выражение&gt; ...)</A></A></P>
<P><A HREF="#_Toc465260937"> (last &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260938"> (length &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260939"> (list &lt;выражение&gt; ...)</A></P>
<P ><A HREF="#_Toc465260940"> (listp &lt;элемент&gt;)</A></P>
<P><A HREF="#_Toc465260941"> (load &lt;имя файла&gt;)</A></P>
<P><A HREF="#_Toc465260942"> (log &lt;число&gt;)</A></P>
<P><A HREF="#_Toc465260943">(logand &lt;число&gt; &lt;число&gt; ...)</A></P>
<P><A HREF="#_Toc465260944"> (logior &lt;число&gt; &lt;число&gt; ...)</A></P>
<P><A HREF="#_Toc465260945"> (lsh &lt;число1&gt; &lt;число бит&gt;)</A></P>
<P>&nbsp;</P>

<P><a name="#m"><A HREF="#_Toc465260946"> (mopcar &lt;функция&gt; &lt;список1&gt;...&lt;списокn&gt;)</A></A></P>
<P><A HREF="#_Toc465260947"> (max &lt;число&gt; &lt;число&gt;...)</A></P>
<P ><A HREF="#_Toc465260948"> (member &lt;выражение&gt; &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260949"> (menucmd &lt;строка&gt;)</A></P>
<P><A HREF="#_Toc465260950"> (min &lt;число&gt; &lt;число&gt;...)</A></P>
 
<P ><A HREF="#_Toc465260951">(minusp &lt;элемент&gt;)</A></P>
<P >&nbsp;</P>
 
<P><a name="#n"><A HREF="#_Toc465260952">(not &lt;элемент&gt;)</A></A></P>
<P><A HREF="#_Toc465260953">(nth &lt;n&gt; &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260954">(null &lt;элемент&gt;)</A></P>
<P><A HREF="#_Toc465260955">(numberp &lt;элемент&gt;)</A></P>
<P>&nbsp;</P>
<P><a name "#O"><A HREF="#_Toc465260956"> (open &lt;имя файла&gt; &lt;режим&gt;)</A></A></P>
<P ><A HREF="#_Toc465260957"> (or &lt;выражение&gt;...)</A></P>
<P><A HREF="#_Toc465260958"> (osnap &lt;точка&gt; &lt;строка-режим&gt;)</A></P>
<P>&nbsp;</P>
<P ><a name="#p"><A HREF="#_Toc465260959">pi</A></A></P>
<P><A HREF="#_Toc465260960">(polar &lt;точка&gt; &lt;угол&gt; &lt;расстояние&gt;)</A></P>
<P><A HREF="#_Toc465260961">(prin1 &lt;выражение&gt; [&lt;описатель файла&gt;])</A></P>
<P><A HREF="#_Toc465260962">(princ &lt;выражение&gt; [&lt;описатель файла&gt;])</A></P>
<P><A HREF="#_Toc465260963">(print &lt;выражение&gt; [&lt;описатель файла&gt;])</A></P>
<P><A HREF="#_Toc465260964">(progn &lt;выражение&gt;...)</A></P>
<P><A HREF="#_Toc465260965"> (prompt &lt;сообщение&gt;)</A></P>
<P>&nbsp;</P>

<P ><a name="#q"><A HREF="#_Toc465260966">(quote &lt;выражение&gt;)</A></A></P>
<P >&nbsp;</P>

<P><a name="#r"><A HREF="#_Toc465260967">(read &lt;строка&gt;)</A></A></P>
<P><A HREF="#_Toc465260968">(read-char [&lt;описатель файла&gt;])</A></P>
<P><A HREF="#_Toc465260969">(read-line [&lt;описатель файла&gt;])</A></P>
<P ><A HREF="#_Toc465260970"> (redraw [&lt;имя примитива&gt; [&lt;режим&gt;]])</A></P>
<P><A HREF="#_Toc465260971">(rem &lt;число1&gt; &lt;число2&gt;)</A></P>
<P><A HREF="#_Toc465260972">(repeat &lt;число&gt; &lt;выражение&gt;...)</A></P>
<P><A HREF="#_Toc465260973">(reverse &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260974">(rtos &lt;число&gt; [&lt;режим&gt; [&lt;точность&gt;]])</A></P>
<P>&nbsp;</P>

<P><a name ="#s"><A HREF="#_Toc465260975"> (set &lt;символ&gt; &lt;выражение&gt;)</A></A></P>
<P><A HREF="#_Toc465260976">(setq &lt;символ1&gt; &lt;выражение1&gt; [&lt;символ2&gt; &lt;выражение2&gt;]...)</A></P>
<P ><A HREF="#_Toc465260977">(setvar &lt;имя-переменной&gt; &lt;значение&gt;)</A></P>
<P><A HREF="#_Toc465260978"> (sin &lt;угол&gt;);</A></P>
<P><A HREF="#_Toc465260979"> (sqrt &lt;число&gt;)</A></P>
<P><A HREF="#_Toc465260980">(strcase &lt;строка&gt; [&lt;признак&gt;])</A></P>
<P><A HREF="#_Toc465260981">(strcat &lt;строка1&gt; &lt;строка2&gt;...)</A></P>
<P><A HREF="#_Toc465260982">(strlen &lt;строка&gt;)</A></P>
<P><A HREF="#_Toc465260983">(subst &lt;новый элемент&gt; &lt;старый элемент&gt; &lt;список&gt;)</A></P>
<P><A HREF="#_Toc465260984">(substr &lt;строка&gt; &lt;начало&gt; [&lt;длина&gt;])</A></P>
<P>&nbsp;</P>

<P><a name="#t"><A HREF="#_Toc465260985"> (terpri)</A></A></P>
<P><A HREF="#_Toc465260986">(textscr)</A></P>
<P><A HREF="#_Toc465260987">(trace &lt;функция&gt;...);</A></P>
<P><A HREF="#_Toc465260988">(type &lt;элемент&gt;)</A></P>
<P>&nbsp;</P>
<P><a name="#u"><A HREF="#_Toc465260989">(untrace &lt;функция&gt;...)</A></A></P>
<P>&nbsp;</P>
<P><a name="#v"><A HREF="#_Toc465260990"> (ver)</A></A></P>
<P>&nbsp;</P>
<P><a name="#w"><A HREF="#_Toc465260991">(while &lt;тест-выражение&gt; &lt;выражение&gt;...)</A></A></P>
<P><A HREF="#_Toc465260992">(write-char &lt;число&gt; [&lt;описатель файла&gt;])</A></P>
<P ><A HREF="#_Toc465260993">((write-line &lt;строка&gt; [&lt;описатель файла&gt;])</A></P>
<P >&nbsp;</P>

<P><a name="#z"><A HREF="#_Toc465260994"> (zerop&lt;элемент&gt;)</A></A></P>



<FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">&nbsp;</P>
</FONT>
<P><B><I><A NAME="_Toc465260871">(+ &lt;число&gt; &lt;число&gt;...)</A> </i></B></P>
<P>Эта функция возвращает сумму всех &lt;чисел&gt;. Она может использоваться как 
  с целыми, так и с действительными числами. Если все &lt;числа&gt; целые, результат 
  будет целым; если хотя бы одно &lt;число&gt; действительное, все целые будут 
  преобразованы в действительные и результат будет действительным. Например:</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (+ 1 2)</font><FONT FACE="Times New Roman">          &#9;&#9;возвращает     3</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (+ 1 2 3 4.5)</font><FONT FACE="Times New Roman">    &#9;возвращает     10.500000</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">+ 1 2 3 4.0)</FONT><FONT FACE="Times New Roman">    &#9;возвращает     10.000000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172630"><A NAME="_Ref465173378"><A NAME="_Toc465260872">(- 
  &lt;число&gt; &lt;число&gt;...)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция вычитает второе &lt;число&gt; из первого и возвращает разность. Если задано более двух &lt;чисел&gt;, то из первого вычитается сумма остальных. Если задано только одно &lt;число&gt;, оно вычитается из 0 и возвращается результат. Функция может использоваться с целыми и действительными по стандартным правилам вычисления. Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (- 50 40)   </font><FONT FACE="Times New Roman">     &#9;возвращает     10</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">- 50 40.0 2)</FONT><FONT FACE="Times New Roman">    &#9;&#9;возвращает     8.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (- 50 40.0 2.5)</font><FONT FACE="Times New Roman">   &#9;возвращает     7.500000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (- 8)</font><FONT FACE="Times New Roman">                          &#9;возвращает     -8</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172631"><A NAME="_Ref465173381"><A NAME="_Toc465260873">(* 
  &lt;число&gt; &lt;число&gt;...)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает произведение всех &lt;чисел&gt;. Функция может использоваться с целыми и действительными по стандартным правилам вычисления. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY">(<FONT FACE="Courier New">* 2 3)</FONT><FONT FACE="Times New Roman">           &#9;&#9;возвращает     6</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">* 2 3 4.0)</FONT><FONT FACE="Times New Roman">      &#9;&#9;возвращает     24.000000</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">* 3 -4.5)</FONT><FONT FACE="Times New Roman">        &#9;&#9;возвращает     -13.500000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172632"><A NAME="_Ref465173384"><A NAME="_Toc465260874">(/ 
  &lt;число&gt; &lt;число&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция делит первое &lt;число&gt; на второе и возвращает частное. Если задано более двух &lt;чисел&gt;, первое делится на произведение остальных и возвращается окончательное частное. Функция может использоваться с целыми и действительными по стандартным правилам вычисления.</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"> Например</font>:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (/ 100 2)</font><FONT FACE="Times New Roman">            &#9;возвращает     50</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">/ 100 2.0)</FONT><FONT FACE="Times New Roman">         &#9;&#9;возвращает     50.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (/ 100 20 2.0)</font><FONT FACE="Times New Roman">   &#9;возвращает     2.500000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (/ 100 20.0 2)</font><FONT FACE="Times New Roman">   &#9;возвращает     2.500000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (/ 100 20 2)</font><FONT FACE="Times New Roman">      &#9;возвращает     2</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (/ 135 360)</font><FONT FACE="Times New Roman">         &#9;возвращает     </FONT>0</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">  (/ 135 360.0)</font><FONT FACE="Times New Roman">     &#9;возвращает     0.375000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172633"><A NAME="_Ref465173386"><A NAME="_Toc465260875">(= 
  &lt;атом&gt; &lt;атом&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция сравнения "равно". Если все &lt;атомы&gt; эквивалентны - возвращается Т, если хотя бы один не равно - nil. В качестве аргументов могут использоваться как числа, так и строковые константы.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">= 4 4.0)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает     Т</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">= 20 388)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">= 2.4 2.4 2.4)</FONT><FONT FACE="Times New Roman">&#9;возвращает     Т</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">= 499 499 500)</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">= "я" "я")</FONT><FONT FACE="Times New Roman">&#9;возвращает     Т</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">= "я" "ты")</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172634"><A NAME="_Ref465173388"><A NAME="_Toc465260876">(/= 
  &lt;атом1&gt; &lt;атом2&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция сравнения "не равно". Если &lt;атом1&gt; не эквивалентен &lt;атому2&gt; - возвращается Т, если они эквивалентны - nil. Функция неопределена для числа аргументов более двух.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P><DIR>
<DIR>

<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">/= 10 20)&#9;</FONT><FONT FACE="Times New Roman">&#9;возвращает     Т</font></P></DIR>
</DIR>

<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">/= "ты" ты")</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">/= 5.43 5.44)</FONT><FONT FACE="Times New Roman">&#9;возвращает     Т</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172635"></A><A NAME="_Ref465173389"></A><A NAME="_Toc465260877"></A><FONT FACE="Arial">(&lt; 
  &lt;атом&gt; &lt;атом&gt;...)</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция сравнения "меньше, чем". Если первый &lt;атом&gt; меньше, чем второй - возвращается Т, если нет - nil. Если дано более 2-х &lt;атомов&gt;, то, если каждый предыдущий атом меньше последующего, - возвращается Т. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt; 10 20)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает     Т</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt; "b" "c")</FONT><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt; 357 33.2)</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt; 2 3 88)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt; 2 3 4 4)</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172636"><A NAME="_Ref465173394"><A NAME="_Toc465260878">(&lt;= 
  &lt;атом&gt; &lt;атом&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция сравнения "меньше или равно". Если первый &lt;атом&gt; меньше или равен второму - возвращается Т, если нет - nil. Если дано более 2-х &lt;атомов&gt;, то, если каждый предыдущий атом меньше или равен последующему, возвращается Т.</P>
<P ALIGN="JUSTIFY"> Например: </P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&lt;= 10 20)</font><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt;= "b" "b")</FONT><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt;= 357 33.2)</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt;= 2 9 9)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает  </FONT>   T</P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">&lt;= 2 9 4 5)</FONT><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172637"><A NAME="_Ref465173395"><A NAME="_Toc465260879">(&gt; 
  &lt;атом&gt; &lt;атом&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция сравнения "больше". Если первый &lt;атом&gt; больше, чем второй - возвращается Т, если нет - nil. Если дано более 2-х &lt;атомов&gt;, то, если каждый предыдущий атом больше последующего, - возвращается Т</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt; 120 17)</font><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt; "c" "b")</font><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt; 3.5 1792)</font><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt; 77 4 2)&#9;</font><FONT FACE="Times New Roman">возвращает     T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt; 77 4 4)</font><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172638"><A NAME="_Ref465173396"><A NAME="_Toc465260880">(&gt;= 
  &lt;атом&gt; &lt;атом&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция сравнения "больше или равно", Если первый &lt;атом&gt; больше или равен второму - возвращается Т, если нет - nil. Если дано более 2-х &lt;атомов&gt;, то, если каждый предыдущий атом больше или равен последующему, - возвращается Т.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt;= 120 17)</font><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt;= "c" "c")</font><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt;= 3.5 1792) &#9;</font><FONT FACE="Times New Roman">возвращает     nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt;= 77 4 4)</font><FONT FACE="Times New Roman">&#9;возвращает     T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(&gt;= 77 4 9)</font><FONT FACE="Times New Roman">&#9;возвращает     nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172639"><A NAME="_Ref465173397"><A NAME="_Toc465260881">(~ 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает логическое НЕТ (дополнение до единицы). &lt;Число&gt;</P>
<P ALIGN="JUSTIFY">должно быть целым. Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(~ 3)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;-4</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">~ 100)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;-100</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(~ -4)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172640"><A NAME="_Ref465173398"><A NAME="_Toc465260882">(1+ 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Результат функции - &lt;число&gt;, увеличенное на единицу. &lt;Число&gt; может быть целым или действительным</P>
<P ALIGN="JUSTIFY">Например: </P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(1+ 5)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;6</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(1+ -17.5)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;-16.500000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172641"><A NAME="_Ref465173399"><A NAME="_Toc465260883">(1- 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Результат функции - &lt;число&gt;, уменьшенное на единицу. &lt;Число&gt; может быть целым или действительным</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">1- 5)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;4</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(1- -17.5)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;-18.500000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172642"><A NAME="_Ref465173403"><A NAME="_Toc465260884"> 
  (abs &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает абсолютное значение &lt;числа&gt;. &lt;Число&gt; может быть целым или действительным.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">abs 100)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;100</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">abs -100)</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;100</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">abs -99.25)</FONT><FONT FACE="Times New Roman">&#9;возвращает&#9;99.250000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172643"><A NAME="_Ref465173404"><A NAME="_Toc465260885"> 
  (and &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает результат выполнения логического И над списком выражений. Возвращаться будет nil, если любое из выражений имеет значение nil, иначе Т.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 103)</P>
<P ALIGN="JUSTIFY">(setq b nil)</P>
<P ALIGN="JUSTIFY">(setq c "string")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(and 1.4 a c)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(and 1.4 a b c)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172644"><A NAME="_Ref465173405"><A NAME="_Toc465260886">(angle 
  &lt;точ1&gt; &lt;точ2&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает угол (в радианах) между 2-мя лучами, направленными из 2-х мерной &lt;точ1&gt;. Первый - вдоль оси Х в сторону положительного направления, второй - в сторону 2-х мерной &lt;точ2&gt;, где 2-х мерная точка - список 2-х действительных чисел.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">angle '(1.0 1.0) '(1.0 4.0))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;1.570796</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">angle '(5.0 1.33) '(2.4 1.33))&#9;</FONT><FONT FACE="Times New Roman">возвращает&#9;3.141593</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172645"></A><A NAME="_Ref465173406"></A><A NAME="_Toc465260887"></A><FONT FACE="Arial">(angtos 
  &lt;</font><FONT FACE="Arial">угол&gt; [&lt;представление&gt; [&lt;точность&gt;]])</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция берет &lt;угол&gt; (действительное число, в радианах) и возвращает его преобразованным в строковую константу. Аргумент &lt;представление&gt;</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=437>
<TR><TD WIDTH="24%" VALIGN="TOP">
<P ALIGN="CENTER">ANGTOS</TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Формат преобразования</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Градусы </FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Градусы/минуты/секунды</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<P ALIGN="CENTER">2</TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Грады</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<P ALIGN="CENTER">3</TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Радианы</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Геодезическое представление</FONT></TD>
</TR>
</TABLE>
<p></P>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Аргумент &lt;точность&gt; - целое число, указывает количество цифр после запятой. Аргументы &lt;представление&gt; и &lt;точность&gt; обращаются к переменным AutoCADа AUNITS и AUPREC. Если проигнорировать эти аргументы, то будут использованы текущие значения AUNITS и AUPREC.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq pt1 '(5.0 1.33))</P>
<P ALIGN="JUSTIFY">(setq pt2 '(2.4 1.33))</P>
<P ALIGN="JUSTIFY">(setq a (angle pt1 pt2))</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(angtos a 0 0)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"180"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(angtos a 0 4)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"180.0000"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(angtos a 1 4)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"180d0'0""</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(angtos a 3 4)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"3.1416r"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(angtos a 4 2)&#9;</font><FONT FACE="Times New Roman">возвращает&#9;"W"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172646"><A NAME="_Ref465173407"><A NAME="_Toc465260888">(append 
  &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция берет любое число списков (&lt;выражений&gt;) и сливает их вместе как один список.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(append '(a b) '(c d))</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает (A B C D)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(append '((a) (b)) '((c) (d)))</font><FONT FACE="Times New Roman">&#9; возвращает ((A) (B) (C) (D))</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">APPEND требует, чтобы аргументы были списками.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172647"><A NAME="_Ref465173408"><A NAME="_Toc465260889">(apply 
  &lt;функция&gt; &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Выполняется &lt;функция&gt; с аргументами, заданными &lt;списком&gt;. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(apply '+ '(1 2 3))</font><FONT FACE="Times New Roman">&#9;&#9;&#9;&#9;возвращает&#9;6</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(apply 'strcat '("a" "b" "c"))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"abc</FONT>"</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">APPLY работает как со встроенными функциями (субр), так и с функциями, определенными пользователем (они создаются с помощью функций DEFUN или LAMBDA).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172648"><A NAME="_Ref465173409"><A NAME="_Toc465260890">(ascii 
  &lt;строковая константа&gt;)</A></A></A> </P>
</font></i></B><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY"> Функция возвращает преобразование символа &lt;строковая константа&gt;  в его ASCII-символьный код (целое число). Эта функция подобна функции ASC в Бейсике</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ascii "A")</font><FONT FACE="Times New Roman">&#9;возвращает     65</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ascii "a")</font><FONT FACE="Times New Roman">&#9;возвращает     97</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ascii "BIG")</font><FONT FACE="Times New Roman">&#9;возвращает     66</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172649"><A NAME="_Ref465173412"><A NAME="_Toc465260891">(assoc 
  &lt;элемент списка&gt; &lt;структурированный список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция просматривает &lt;структурированный список&gt; по ключу &lt;элемент списка&gt; и возвращает точку входа &lt;структур. списка&gt;. Если &lt;элемент списка&gt; не найден, ASSOC возвращает nil. Например допустим, что "al" определен как: </P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">((name box) (width 3) (size 4.7263) (depth 5))</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(assoc 'size al)</font><FONT FACE="Times New Roman">&#9;возвращает (SIZE 4.7363)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(assoc 'weight al)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Структурированные списки часто используются для хранения данных, к которым можно иметь доступ по ключу. Это похоже на структуры и массивы в других языках программирования. Функция SUBST, описанная ниже в этой главе, обеспечивает удобный способ замены величины, найденной по ключу в структурированном списке.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172650"><A NAME="_Ref465173413"><A NAME="_Toc465260892">(atan 
  &lt;число1&gt; [&lt;число2&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если &lt;число2&gt; не задано, ATAN вычисляет арктангенс &lt;числа1&gt;, в радианах. &lt;Число1&gt; может быть отрицательным; область допустимых значений от -pi до +pi радиан.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atan 0.5)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;0.463647</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atan 1.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;0.785398</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atan -1.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;-0.785398</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(angtos (atan -1.0) 0 4)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"-45.0000"</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если заданы оба числа, возвращается арктангенс (&lt;число1&gt;/&lt;число2&gt;) в радианах. Если &lt;число2&gt; - ноль, в зависимости от знака &lt;числа1&gt;, возвращается + или -1.570796 радиан (90 или -90 градусов).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172651"><A NAME="_Ref465173414"><A NAME="_Toc465260893">(atof 
  &lt;строковая константа&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает преобразование &lt;строковой константы&gt; в действительное число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">atof "97.1")</FONT><FONT FACE="Times New Roman">&#9;возвращает&#9; 97.100000</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">atof "3")</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;3.000000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172652"><A NAME="_Ref465173416"><A NAME="_Toc465260894">(atoi 
  &lt;строковая константа&gt; )</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает преобразование &lt;строковой константы&gt; в целое число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atoi "97")</font><FONT FACE="Times New Roman">&#9;возвращает&#9;9</FONT>7</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atoi "3")</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atoi "3.9")</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172653"><A NAME="_Ref465173417"><A NAME="_Toc465260895">(atom 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если &lt;элемент&gt; - список - возвращается nil, иначе Т.  Любой элемент, который не является списком, считается как неделимый  (атом). </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a '(x y z))</P>
<P ALIGN="JUSTIFY">(setq b 'a)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atom 'a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atom a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atom 'b)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atom b)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(atom '(a b c))</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Некоторые версии LISPа различаются в своей интерпретации функции  АТОМ, так что будьте внимательны при переходе из одной версии в другую.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172654"><A NAME="_Ref465173418"><A NAME="_Toc465260896"> 
  (Boole &lt;функция&gt; &lt;целое1&gt; &lt;целое2&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Это основная битовая Булева функция. &lt;Функция&gt; - это целое число между  0 и 15, представляющее одну из 16 возможных Булевых функций двух переменных. Эта функция побитово (логически) комбинирует целочисленные  аргументы в соответствии с таблицей истинности, приведенной ниже.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=318>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Целое 1</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Целое 2</FONT></TD>
<TD WIDTH="37%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Код функции</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">8</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">2</TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="37%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
</TR>
</TABLE>
<p></P>

<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Каждый бит &lt;целого1&gt; берется совместно с соответствующим битом &lt;целого2&gt;, и помещается в одну из строк таблицы истинности. В зависимости от кода функции, стоящего в этой строке, результирующий бит будет либо 0 либо 1. Если в &lt;функции&gt; установлен подходящий бит, результирующий бит - 1, иначе - 0.</P>
<P ALIGN="JUSTIFY">Некоторые значения &lt;функции&gt; эквивалентны стандартным Булевым операциям  И, ИЛИ, исключающему ИЛИ, HЕ:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=626>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция </FONT></TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Операция </FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Результирующий бит 1, если…</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">И</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Оба бита равны 1</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<P ALIGN="CENTER">6</TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Искл. ИЛИ</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Только один из двух битов равен 1</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<P ALIGN="CENTER">7</TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">ИЛИ</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Каждый или оба бита равны 1</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<P ALIGN="CENTER">8</TD>
<TD WIDTH="23%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">НЕ</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Оба бита равны 0(дополнение до 1)</FONT></TD>
</TR>
</TABLE>
<p></P>

<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(Boole 1 12 5)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">задает логическое И значений 12 и 5. Результат 4. Подобно:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(Boole 6 6 5)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">задает логическое исключающее ИЛИ значений 6 и 5, возвращая 3.</P>
<P ALIGN="JUSTIFY">Вы можете использовать другие значения &lt;функции&gt; для задания других  Булевых операций, не имеющих стандартных имен. Например, если &lt;функция&gt; задана числом 4, результирующий бит задается, если соответствующий бит  установлен в аргументе &lt;целое2&gt;, а не в &lt;целое1&gt;. Так:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(Boole 4 3 14)&#9;</font><FONT FACE="Times New Roman">возвратит&#9;12.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172655"><A NAME="_Ref465173419"><A NAME="_Toc465260897">(boundp 
  &lt;атом&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает - Т, если &lt;атом&gt; имеет некоторое значение (в  широком смысле). Если &lt;атом&gt; не имеет никакого значения, или равен nil,  возвращается nil.</P>
<P ALIGN="JUSTIFY">Например, допустим:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 2)</P>
<P ALIGN="JUSTIFY">(setq b nil)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(boundp 'a)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(boundp 'b)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172656"><A NAME="_Ref465173422"><A NAME="_Toc465260898">caar, 
  cadr, cddr, cadar, и т.д.</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">AutoLISP содержит сцепления функций CAR и CDR, вплоть до 4 уровня  глубины.</P>
<P ALIGN="JUSTIFY"> Например, допустим:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq x '((a b) c d))</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(caar x)</font><FONT FACE="Times New Roman">&#9;эквивалентно</FONT><FONT FACE="Courier New">(car (car x))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает  A</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cdar x)&#9;</font><FONT FACE="Times New Roman">эквивалентно</FONT><FONT FACE="Courier New">(cdr (car x))&#9;&#9;</FONT><FONT FACE="Times New Roman">возвращает  (B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cadar x)&#9;</font><FONT FACE="Times New Roman">эквивалентно</FONT><FONT FACE="Courier New">(car (cdr (car x)))&#9;</FONT><FONT FACE="Times New Roman">возвращает  </FONT>B</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cadr x)</font><FONT FACE="Times New Roman">&#9;эквивалентно</FONT><FONT FACE="Courier New">(car (cdr x))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает  C</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cddr x)</font><FONT FACE="Times New Roman">&#9;эквивалентно</FONT><FONT FACE="Courier New">(cdr (cdr x))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает  (D)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(caddr x)&#9;</font><FONT FACE="Times New Roman">эквивалентно</FONT><FONT FACE="Courier New"> (car (cdr (cdr x)))&#9;</FONT><FONT FACE="Times New Roman">возвращает  D</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В AutoLISPе CADR часто используется для "извлечения" координаты  Y 2-х мерной и 3-х мерной точки (второй элемент списка, состоящего из  2-х или 3-х натуральных чисел). Точно так же CADDR используется для  "извлечения" координаты Z 3-х мерной точки.</P>
<P ALIGN="JUSTIFY"> Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq pt2 '(5.2 1.0))</font>&#9;&#9;(<I><FONT FACE="Times New Roman">2-х мерная точка)</font></i></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq pt3 '(5.2 1.0 3.0))</font>&#9;(<I><FONT FACE="Times New Roman">3-х мерная точка)</font></i></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(car pt2)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;5.200000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cadr pt2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;1.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(caddr pt2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(car pt3)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;5.200000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cadr pt3)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;1.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(caddr pt3)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3.000000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172657"><A NAME="_Ref465173423"><A NAME="_Toc465260899">(car 
  &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает первый элемент &lt;списка&gt;. Если список пуст,  возвращается nil.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(car '(a b c))</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;A</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(car '((a b) c))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;(A B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(car '())</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172658"><A NAME="_Ref465173424"><A NAME="_Toc465260900">(cdr 
  &lt;список&gt; )</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Функция возвращает все элементы &lt;списка&gt;, кроме первого. Если  &lt;список&gt; пуст, возвращается n</font>il.</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cdr '(a b c))</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;(B C)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cdr '((a b) c))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;(C)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cdr '())</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Когда аргументом &lt;списка&gt; является точечная пара (смотрите CONS, ниже),  CDR возвращает второй элемент, не заключая его в список.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">cdr '(a . b))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;</FONT>B</P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">cdr '(1 . "Text"))</FONT><FONT FACE="Times New Roman">&#9;возвращает&#9;"Text"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172659"><A NAME="_Ref465173425"><A NAME="_Toc465260901">(chr 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает преобразование целого числа в символьный код ASCII  и результатом является строковая константа, (подобным образом действует  функция CHR$ в языке Бейсик).</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(chr 65)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"A"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(chr 66)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"B"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(chr 97)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"a"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172660"><A NAME="_Ref465173426"><A NAME="_Toc465260902">(close 
  &lt;описатель файла&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция закрывает файл и возвращает nil. &lt;Описатель файла&gt; извлекается из функции OPEN. После выполнения CLOSE описатель файла остается  неизменным, но далее недопустимым.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Например, предположим, что Х допустимый файловый описатель открытого файла,</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(close x)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">закроет соответствующий файл и возвратит nil.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172661"><A NAME="_Ref465173427"><A NAME="_Toc465260903">(command 
  &lt;аргумент&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция выполняет команды AutoCADа в AutoLISPе и всегда возвращает nil. Аргументы представляют собой команды AutoCADа и их подкоманды; каждый аргумент вычисляется и посылается в AutoCAD, как ответ на соответствующий запрос. Командные имена и опции представляются как строковые константы, 2-х мерные точки - как списки из 2-х действительных чисел, и 3-х мерные точки - как списки из 3-х действительных чисел. Командные имена воспринимаются AutoCADом только после подсказки "Command:" /команда:/.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq pt1 '(1.45 3.23))</P>
<P ALIGN="JUSTIFY">(setq pt2 (getpoint "Enter a point: "))</P>
<P ALIGN="JUSTIFY">(command "line" pt1 pt2)</P>
<P ALIGN="JUSTIFY">(command "")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если допустить, что подсказка "Command:" существует, то записанные выше выражения устанавливают значения для точки "pt1", запрашивают у Вас точку "pt2" и выполняют команду AutoCADа LINE по двум заданным точкам. Аргументы функции COMMAND могут быть строковыми константами, действительными числами, целыми или точками, то есть такими, какие ожидает получить от Вас выполняемая команда в ответ на ее запросы. Пустая строка ("") равносильна нажатию пробела на клавиатуре. Вызов COMMAND без аргумента равносилен нажатию CTRL C на клавиатуре, и прерывает большинство команд AutoCADа.</P>
<P ALIGN="JUSTIFY">Команды, выполняемые функцией COMMAND не имеют эха на экране, если переменная AutoCADа CMDECHO (доступна из функций SETVAR и GETVAR ) установлена равной нулю. Функция COMMAND - основной метод доступа из AutoLISPа к командам AutoCADа.</P>
<P ALIGN="JUSTIFY"> Вводимые пользователем функции "GETxxx" (GETANGLE,GETSTRING, GETINT,GETPOINT и т.д.) не могут быть вложенными в функции COMMAND. Попытка сделать это вызовет сообщение "error: AutoCAD rejected function" (ошибка: неверная команда AutoCADа) и вызовет аварийный останов выполнения функции. При необходимости, задавайте функции GETxxx заранее или помещайте их между смежными функциями COMMAND.</P>
<P ALIGN="JUSTIFY">Команды AutoCADа DTEXT и SKETCH считывают информацию непосредственно с клавиатуры и дигитайзера и поэтому не могут использоваться с функцией AutoLISP COMMAND. Также нельзя использовать функцию COMMAND для выполнения команд PLOT, PRPLOT или SCRIPT.</P>
</FONT><B><I><FONT FACE="Arial"><P ALIGN="JUSTIFY"><A NAME="_Toc465172662"><A NAME="_Toc465260904">Прерывание для ввода информации пользователем</A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Если выполняется команда AutoCADа и в строке аргументов встречается символ PAUSE, то функция COMMAND приостановит свое действие, чтобы пользователь непосредственно ввел значение (или произвел отслеживание элемента чертежа). Это похоже на механизм паузы (с помощью backslash</font> <FONT FACE="Times New Roman">"\"), существующий для меню.</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Если вы используете "прозрачную" команду в момент приостановки функции COMMAND, функция COMMAND остается в состоянии паузы до завершения "прозрачной" команды, после чего вернется к нормальному выполнению. Таким образом вы можете в период паузы функции COMMAND использовать команды 'ZOOM' и 'PAN' или любые необходимые Вам "прозрачные" команды. Пауза буде продолжаться до тех пор, пока не будет введен имеющий силу аргумент и пока не выполняться все "прозрачные" команды.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(command "circle" "5,5" pause "line" "5,5" "7,5" "")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">начинается команда CIRCLE, устанавливающая центр круга в точку 5,5, и затем прервется, давая возможность пользователю задать радиус круга, например, методом слежения. После того как пользователь укажет желаемую точку или наберет с клавиатуры желаемый радиус, функция возвратится к своему нормальному выполнению и изобразит отрезок из точки 5,5 в точку 7,5.</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Ввод с помощью меню не исключается паузой AutoLISPа. Если активизировано меню и функция COMMAND требует ввода, находясь в паузе, запрос может быть удовлетворен с помощью меню. Если вы хотите также приостановить действие меню, в меню следует предусмотреть backslash. Когда будет дан имеющий силу ответ, и функция COMMAND и функция меню возобновят свою работу</font>.</P>
<B><U><FONT FACE="Times New Roman" SIZE=4 COLOR="#800000">
<P ALIGN="JUSTIFY"><font color="#006666">ЗАМЕЧАНИЯ:</font></P>

</font></u></B><UL><FONT FACE="Times New Roman" SIZE=4 COLOR="#800000"><U><B>
</b></u></font><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY"><LI>Символ PAUSE является строковой константой со значением backslash. Вы можете использовать backslash непосредственно вместо символа PAUSE, однако если функция COMMAND используется как элемент меню, то backslash будет восприниматься не как аргумент функции COMMAND, но как опция элемента меню, который выполняется в текущий момент. Кроме того механизм прерывания может запрашивать различные управляющие значения в последующих версиях AutoLISPа, поэтому мы рекомендуем во всех случаях пользоваться символом PAUSE вместо backslash. </LI><p></P></font></UL><FONT FACE="Times New Roman">


<UL>
<P ALIGN="JUSTIFY"><LI>Если PAUSE встречается в команде, требующей ввода текста или значения Атрибута, AutoCAD прервется для ввода, только если значение системной переменной TEXTEVAL не равно нулю. В противном случае значение символа PAUSE - backslash будет воспринято как текст и прерывания для ввода не произойдет.</LI><p></P></UL>


<UL>
<P ALIGN="JUSTIFY"><LI>Когда выполнение функции COMMAND прервано для ввода, функция находится в состоянии "active" /на выполнении/, поэтому пользователь не может вводить для выполнения другие выражения AutoLISPа.</LI><p></P></UL>

</FONT><B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172663"><A NAME="_Ref465173444"><A NAME="_Toc465260905">(cond 
  (&lt;тест1&gt; &lt;результат&gt;...)...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция воспринимает любое число списков как аргументы. Она оценивает первый элемент списка (по очереди) до тех пор, пока не встретится отличный от nil. Затем вычисляется то выражение, которое следует за тестом и возвращает значение последнего выражения в подсписке. Если в подсписке только одно выражение (например, &lt;результат&gt; отсутствует), возвращается значение выражения &lt;тест&gt;. COND - основная функция условия в AutoLISPе.</P>
<P ALIGN="JUSTIFY">Например, использование функции COND для вычисления абсолютного значения числа:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">               (cond ((minusp a) (- a))</P>
<P ALIGN="JUSTIFY">                     (t a)</P>
<P ALIGN="JUSTIFY">                   )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если в "а" было установлено значение -10, будет возвращено 10. Как видно, COND может использоваться как функция типа "case" /в случае.../.  Принято в качестве последнего (по умолчанию) выражения &lt;тест&gt; использовать символ T.</P>
<P ALIGN="JUSTIFY">Еще один простой пример. Задавая запрос пользователя  в символ "s", эта функция проверяет ответ и возвращает 1, если ответ "  Y" или "y", а если ответ "N" или "n", то 0, иначе nil.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">              (cond ((= s "Y") 1)</P>
<P ALIGN="JUSTIFY">                    ((= s "y") 1)</P>
<P ALIGN="JUSTIFY">                    ((= s "N") 0)</P>
<P ALIGN="JUSTIFY">                    ((= s "n") 0)</P>
<P ALIGN="JUSTIFY">                    (t nil)</P>
<P ALIGN="JUSTIFY">                  )</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172664"><A NAME="_Ref465173449"><A NAME="_Toc465260906">(CONS 
  &lt;новый первый элемент&gt; &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Это основной конструктор списка. Эта функция берет элемент (&lt;новый  первый элемент&gt;) и &lt;список&gt;, и возвращает список с добавленным элементом  в начало списка. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">             &#9;(cons 'a '(b c d))</font><FONT FACE="Times New Roman">           возвращает (A B C D)</font></P>
<P ALIGN="JUSTIFY">             &#9;&#9;<FONT FACE="Courier New">(cons '(a) '(b c d))</FONT><FONT FACE="Times New Roman">         возвращает ((A) B C D)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Заметим, что первый элемент может быть атомом или списком.</P>
<P ALIGN="JUSTIFY">CONS так же воспринимает атом на месте аргумента &lt;списка&gt;, конструируя  структуру, известную как точечная пара. Показывая точечную пару на экране,  AutoLISP  печатает точку между первым и вторым элементами. Точечные пары  занимают меньше места в памяти, чем обычные списки и можно использовать  функцию CDR для извлечения второго атома.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cons 'a 'b)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;(A . B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(car (cons 'a 'b))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;A</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cdr (cons 'a 'b))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;B</font></P>
<P ALIGN="JUSTIFY"> </P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172665"><A NAME="_Ref465173451"><A NAME="_Toc465260907">(cos 
  &lt;угол&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает косинус &lt;угла&gt;, где &lt;угол&gt; - выражается в  радианах.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cos 0.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;1.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(cos pi)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;-1.000000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172666"><A NAME="_Ref465173452"><A NAME="_Toc465260908">(defun 
  &lt;символ&gt; &lt;список аргументов&gt; &lt;выражение&gt;...)</A></A></A></P>
</font></i></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465260909">Библиотека 
  символов и автоматическая загрузка.&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465260910"> 
  С:ХХХ функции - Добавление команд в AutoCAD.&#9;</A></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">DEFIN - определяет функцию с именем &lt;символ&gt; (заметим, что имя функции автоматически берется в кавычки и поэтому не требуется этого делать самому). Имя, следующее за функцией - это список аргументов (возможно пустой), за которым следует (факультативно) косая черта (slach) и имена одного или более локальных символов функции. Косая черта должна отстоять от первого локального символа и последнего аргумента, если он есть, хотя бы на один пробел. Если нет аргументов и локальных символов, которые следует объявлять, за именем функции следует поставить пустые скобки.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(defun myfunc (x y) ... )</font><FONT FACE="Times New Roman">&#9;(функция берет два аргумента)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(defun myfunc (/ a d) ... )</font><FONT FACE="Times New Roman">&#9;(функция имеет два локальных символа)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(defun myfunc (x / temp) ... )</font><FONT FACE="Times New Roman">(один аргумент и один локальный символ</FONT>)</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(defun myfunc () ... )</font><FONT FACE="Times New Roman">&#9;&#9;(без аргументов и локальных символов)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">За списком аргументов и локальных символов следует одно или более выражений, которые вычисляются в процессе выполнения функции.</P>
<P ALIGN="JUSTIFY">Сама по себе функция DEFUN возвращает имя определяемой функции. Когда функция, определенная таким образом вызывается, ее аргументы вычисляются и связываются в список аргументов. Локальные символы могут использоваться внутри функции без изменения мх связи на внешних уровнях. Функция будет возвращать результат последнего вычисленного выражения. Все предыдущие выражения будут иметь только побочный эффект. Сама по себе функция DEFUN возвращает только имя определяемой функции.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(defun add10 (x)(+ 10 x)&#9;</font><FONT FACE="Times New Roman">возвращает</FONT>&#9;ADD10</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(add10 5)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;&#9;возвращает&#9;15</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(add10 -7.4)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает&#9;2.60000</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">и:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(defun dots (x y / temp)</P>
<P ALIGN="JUSTIFY">(setq temp (strcat x "..."))</P>
<P ALIGN="JUSTIFY">(strcat temp y)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">    )</font><FONT FACE="Times New Roman">&#9;возвращает&#9;DOTS</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(dots "a" "b")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;"a...b"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(dots "from" "to")</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"from...to"</font></P>
<P ALIGN="JUSTIFY"></P>
<B><U><FONT FACE="Times New Roman" SIZE=4 COLOR="#800000">
<P ALIGN="JUSTIFY"><font color="#006666">Никогда не используйте имена встроенных 
  функций или символов как &lt;символ&gt;, так как это сделает недоступными встроенные 
  функции.</font></P>
</FONT><FONT SIZE=4 COLOR="#800000"><P ALIGN="JUSTIFY">&nbsp;</P>
</font></U><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172667"><A NAME="_Ref465173453"><A NAME="_Toc465260909">Библиотека 
  символов и автоматическая загрузка.</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Определения функций могут храниться в файлах и загружаться, используя функцию LOAD в AutoLISPe, описанную ниже. Если существует файл "acad.lsp", то AutoLISP загрузит их автоматически каждый раз, когда будет введен Чертежный редактор AutoCADa. Вы можете использовать это обстоятельство для создания библиотеки используемых функций и быть уверенным, что они всегда под рукой, когда понадобятся.</P>
<P ALIGN="JUSTIFY">Любой библиотечный ".lsp" файл может содержать выражения вне функции DEFUN. Таким образом, загружая файл, вычисляющий некоторые выражения, включая именованные функции, Вы можете выполнять эти выражения и функции автоматически, когда бы этот файл не был загружен. Однако, загрузка файла "acad.lsp" производится еще до полной инициализации Чертежного Редактора AutoCADа, поэтому не следует использовать функции COMMAND в файле "acad.lsp" (вне функции DEFUN).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172668"><A NAME="_Ref465173456"><A NAME="_Toc465260910"> 
  С:ХХХ функции - Добавление команд в AutoCAD.</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Вы можете добавить новые команды в AutoCAD, используя функцию DEFUN,  чтобы определить эти команды как функции. Для того чтобы ими пользоваться  как командами AutoCADа, такие функции должны удовлетворять следующим  правилам:</P>
<P ALIGN="JUSTIFY">1. Имя функции должно быть формы "С:ХХХ", где все буквы - заглавные.  Часть имени "С:" должна всегда присутствовать; часть имени "ХХХ" может  быть любым именем команды на ваш выбор, только не должна дублировать  какую-либо команду AutoCADa, внешнюю или встроенную функцию.</P>
<P ALIGN="JUSTIFY">2. Функция должна быть определена без аргументов - пустой список  (хотя локальные символы допускаются).</P>
<P ALIGN="JUSTIFY">Например, следующая запись определяет функцию, изображающую на экране</P>
<P ALIGN="JUSTIFY">квадрат с помощью Полилинии:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">   (defun C:PSQUARE (/ pt1 pt2 pt3 pt4 len)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">      (setq pt1 (getpoint "</font><FONT FACE="Courier New">Lower left corner: ")) /Hижний левый угол: /</font></P><FONT FACE="Courier New">
<P ALIGN="JUSTIFY">      (setq len (getdist pt1 "Length of one side: ")) /Длина стороны: /</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">      (setq pt2 (polar pt1 0.0 len))</P>
<P ALIGN="JUSTIFY">      (setq pt3 (polar pt2 (/ PI 2.0) len))</P>
<P ALIGN="JUSTIFY">      (setq pt4 (polar pt3 PI len))</P>
<P ALIGN="JUSTIFY">      (command "PLINE" pt1 pt2 pt3 pt4 "C")</P>
<P ALIGN="JUSTIFY">       )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функции определенные таким образом могут вызываться простым вводом  "ХХХ" части имени функции, когда появилось сообщение AutoCADa "Command:". Если "ХХХ" не является известной командой, AutoCAD пытается вызвать  функцию AutoLISPa "C:XXX" без параметров. Для приведенной выше функции  C:PSQUARE диалог будет таким:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">Command: PSQUARE</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">Lower left corner: (ввод точки)</P>
<P ALIGN="JUSTIFY">Length of one side: (ввод расстояния)</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">После чего функция вызовет команду AutoCADа PLINE и ответит на ее запросы  для вычерчивания заданного квадрата.  </P>
<P ALIGN="JUSTIFY">Добавление команд к AutoCADу таким образом - очень мощное средство  AutoLISPa. Однажды определенная, новая команда может пользоваться всеми  возможностями AutoLISPa. Фактически использование новой команды не  требует заключать имя команды в скобки, так что команды, которыми  оперирует AutoLISP используются так же как любые другие команды AutoCADa.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172669"><A NAME="_Ref465173457"><A NAME="_Toc465260911">(distance 
  &lt;точка1&gt; &lt;точка2&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает расстояние между 2-х мерными точками  &lt;точка1&gt; &lt;точка2&gt;, где 2-х мерная точка - это список двух действительных  чисел.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(distance '(1.2 2.5) '(7.7 2.5))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;6.700000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(distance '(1.0 2.0) '(3.0 4.0))&#9;</font><FONT FACE="Times New Roman">возвращает&#9;2.828427</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172670"><A NAME="_Ref465173459"><A NAME="_Toc465260912">(eq 
  &lt;выражение1&gt; &lt;выражение2&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция определяет идентичны ли &lt;выражение1&gt; и &lt;выражение2&gt;, т.е. они фактически относятся к одному объекту (например, с помощью SETQ). EQ возвращает Т, если оба выражения идентичны, иначе nil. Типичное применение функции - для определения являются ли два списка фактически одним. Например, зададимся следующими допущениями:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq f1 '(a b c))</P>
<P ALIGN="JUSTIFY">(setq f2 '(a b c))</P>
<P ALIGN="JUSTIFY">(setq f3 f2)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(eq f1 f3)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;nil (f1 и f3 не одно и то же)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(eq f3 f2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;T (f3 и f2 один и тот же список)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Смотри так же функцию EQUAL ниже.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172671"><A NAME="_Ref465173460"><A NAME="_Toc465260913">(equal 
  &lt;выражение1&gt; &lt;выражение2&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Это функция определяет равны ли &lt;выражение1&gt; и &lt;выражение2&gt;, т.е.  их значение является одно и то же.</P>
<P ALIGN="JUSTIFY">Например, зададимся следующими  допущениями:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq f1 '(a b c))</P>
<P ALIGN="JUSTIFY">(setq f2 '(a b c))</P>
<P ALIGN="JUSTIFY">(setq f3 f2)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(equal f1 f3)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;T(значением f1 и f3 является одно   и то же)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(equal f3 f2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;T(f3 и f2 в точности один и тот же   список)</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Отметим, что в то время, как два списка EQUAL, они могут не быть EQ,  атомы, которые EQUAL всегда к тому же EQ. Добавим, что два списка,  которые EQ, всегда</font> EQUAL.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172672"><A NAME="_Ref465173463"><A NAME="_Toc465260914">(eval 
  &lt;выражение&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает результат выражения &lt;выражение&gt;, где  &lt;выражение&gt; -  любое выражение языка LISP. Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 123)</P>
<P ALIGN="JUSTIFY">(setq b 'a)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(eval 4.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает 4.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(eval (abs -10))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;10</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(eval a)</font>&#9;&#9;&#9;<FONT FACE="Times New Roman">возвращает&#9;123</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(eval b)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает&#9;123</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172673"><A NAME="_Ref465173464"><A NAME="_Toc465260915">(exp 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция вычисляет е в степени &lt;число&gt; (натуральный антилогарифм),  возвращает действительное число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(exp 1.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;2.718282</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(exp 2.2)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;9.025013</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(exp -0.4)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;0.670320</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172674"><A NAME="_Ref465173465"><A NAME="_Toc465260916">(expt 
  &lt;основание&gt; &lt;степень&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает &lt;основание&gt;, возведенное в указанную &lt;степень&gt;.  Если оба аргумента целые, то результат - целое число. В любом другом  случае, результат - действительное число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(expt 2 4)</font><FONT FACE="Times New Roman">&#9;возвращает     16</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(expt 3.0 2.0)</font><FONT FACE="Times New Roman">&#9;возвращает     9.000000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172675"><A NAME="_Ref465173466"><A NAME="_Toc465260917">(fix 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает преобразование &lt;числа&gt; в целое. &lt;Число&gt; может быть  как целым, так и действительным. Если оно действительное, то оно усекается до ближайшего целого путем отбрасывания дробной части.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(fix 3)&#9;</font><FONT FACE="Times New Roman">возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(fix 3.7)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172676"><A NAME="_Ref465173467"><A NAME="_Toc465260918">(float 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает преобразование &lt;числа&gt; в действительное.  &lt;Число&gt; может быть как целым так и действительным.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(float 3)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;3.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(float 3.7)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3.700000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172677"><A NAME="_Ref465173468"><A NAME="_Toc465260919">(foreach 
  &lt;имя&gt; &lt;список&gt; &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция, проходя по &lt;списку&gt;, присваивает каждому элементу &lt;имя&gt; и  вычисляет каждое &lt;выражение&gt; для каждого элемента в списке. Может быть  задано любое число &lt;выражений&gt;. FOREACH выдает результат последнего,  вычисленного &lt;выражения&gt;. Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(foreach n '(a b c) (print n))</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">эквивалентно:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(print a)</P>
<P ALIGN="JUSTIFY">(print b)</P>
<P ALIGN="JUSTIFY">(print c)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">кроме того, что FOREACH возвращает результат только последнего вычисленного выражения.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172678"><A NAME="_Ref465173469"><A NAME="_Toc465260920"> 
  (gcd &lt;число1&gt; &lt;число2&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция возвращает наибольший общий делитель &lt;числа1&gt; и &lt;числа2&gt;.  &lt;Число1&gt; и &lt;число2&gt; должны быть целыми.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(gcd 81 57)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(gcd 12 20)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;4</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172679"><A NAME="_Ref465173470"><A NAME="_Toc465260921">(getangle 
  [&lt;точка&gt;] [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция создает паузу для того, чтобы пользователь ввел угол.  &lt;Подсказка&gt; - факультативная запись для высвечивания на экране в  качестве  подсказки, а &lt;точка&gt; - факультативная 2-х мерная базовая точка. Вы  можете задать угол путем набора числа на клавиатуре в текущих для  AutoCADa единицах измерения. Заметим, что, несмотря на то, что текущая  единица измерения угла может быть градус, град, или какая либо еще,  функция всегда возвращает угол в радианах.</P>
<P ALIGN="JUSTIFY">Вы можете так же "показать" AutoLISPу угол путем указания двух 2-х  мерных точек на экране. AutoCAD нарисует "резиновую" линию от первой  точки к текущему положению курсора для того чтобы визуализировать угол.  Факультативный аргумент GETANGLE - &lt;точка&gt; (если указывается) подразумевается как первая из этих двух точек, позволяя тем самым вам "показать"  AutoLISPу угол, указывая на следующую точку</P>
<P ALIGN="JUSTIFY">Ниже приведены примеры функции GETANGLE.</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">  (setq ang (getangle))</P>
<P ALIGN="JUSTIFY">    (setq ang (getangle '(1.0 3.5))</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">    (setq ang (getangle "Which way? "))             /"В какую сторону? "/</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">    (setq ang (getangle '(1.0 </font><FONT FACE="Courier New">3.5) "Which way? "))  /"В какую сторону? "/</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Вы не можете ввести другое выражение LISPa, как ответ на запрос функции GETANGLE. При попытке сделать так, появится сообщение "Can't reenter  AutoLISP " /"Hе могу войти в AutoLISP"/. Смотрите также GETORIENT INI</font>TGET.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172680"><A NAME="_Ref465173471"><A NAME="_Toc465260922">(getcorner 
  &lt;точка&gt; [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">GETCORNER возвращает точку, так же как GETPOINT. Однако для  GETCORNER требуется &lt;базовая точка&gt; и функция строит прямоугольник от  &lt;базовой точки&gt; в то время как пользователь передвигает курсор по экрану.  Смотрите GETROINT и INITGET для уточнения.</P>
<P ALIGN="JUSTIFY">Вы не можете ввести другое LISP-выражение в ответ на запрос GETCORNER.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172681"><A NAME="_Ref465173474"><A NAME="_Toc465260923">(getdist 
  [&lt;точка&gt;] [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция создает паузу для того, чтобы пользователь ввел расстояние. [&lt;Промпт&gt;] - факультативная запись для высвечивания на экране в качестве подсказки, &lt;точка&gt; - факультативная базовая точка. Вы можете указать расстояние, набрав число на клавиатуре в текущих для AutoCADa единицах измерения. Заметим, какими бы ни были текущие единиц измерения (например, футы или дюймы), функция всегда возвращает расстояние как действительное число.</P>
<P ALIGN="JUSTIFY">Вы можете так же "показать" AutoLISPу расстояние , указав две точки на экране. AutoCAD рисует "резиновую" линию от первой точки до текущего положения курсора для того, чтобы визуалировать расстояние. Факультативный аргумент GETDIST &lt;точка&gt; подразумевается как первый из этих двух точек, позволяя вам "показать" AutoLISPу расстояние, путем указания в любую другую точку.</P>
<P ALIGN="JUSTIFY">Ниже приведены примеры функции GETDIST:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq dist (getdist))</P>
<P ALIGN="JUSTIFY">(setq dist (getdist '(1.0 3.5))</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq dist (getdist "How far? "))             /"Как далеко? "/</P>
<P ALIGN="JUSTIFY">(setq dist (getdist '(1.0 3.5) "How far? "))  /"Как далеко? "/</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Вы не можете ввести другое LISP-выражение как ответ на запрос GETDIST.  Смотрите также INITGET.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172682"></A><A NAME="_Ref465173475"></A><A NAME="_Toc465260924"></A><FONT FACE="Arial">(getint 
  [&lt;подсказка&gt;])</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция ожидает ввода пользователем целого числа и возвращает  его. &lt;Подсказка&gt; - факультативная запись для высвечивания на экране в  качестве подсказки.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq num (getint))</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq num (getint "Enter a number: "))  </font><FONT FACE="Courier New"> /"Введите число: "/</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Вы не можете ввести другое LISP-выражение на запрос GETINT.  Смотрите также INITGET.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172683"><A NAME="_Ref465173476"><A NAME="_Toc465260925">(getkword 
  [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция запрашивает ключевое слово у пользователя. Список имеющих смысл ключевых слов задается, прежде чем вызывается функция GETKWORD, пользуясь функцией INITGET (описывается ниже). GETKWORD возвращает ключевое слово, соответствующее введенному пользователем как строковую константу. AutoCAD переспросит, если введенное не является одним из заданных ключевых слов. Пустой ввод возвращает nil (если позволяется вводить пустой ввод). Если не было установлено ни одного ключевого слова, также возвращается nil.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">      (initget 1 "Yes No")</P>
<P ALIGN="JUSTIFY">      (setq x (getkword "Are you sure? (Yes or No) "))</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">                        </font><FONT FACE="Courier New">     /"Вы уверены? (Да или Hет) "/</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">запросит пользователя и установит в символ Х либо "Yes", либо "No",  в зависимости от его ответа. Если ввод не соответствует ни одному ключевому слову, или же пользователь ответил пустым вводом, AutoCAD попросит  пользователя повторить ввод еще раз.</P>
<P ALIGN="JUSTIFY">Вы не можете ввести другое LISP-выражение на запрос GETKWORD.</P>
<P ALIGN="JUSTIFY">Смотрите также INITGET.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172684"><A NAME="_Ref465173477"><A NAME="_Toc465260926"> 
  (getorient [&lt;точка&gt;] [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">В AutoLISPe углы всегда представляются в радианах с нулевым направлением слева направо (восток) и углы откладываются против часовой стрелки. Таким образом, должны иметь месть некоторые изменения, если пользователь хочет выбрать отсчет в градусах или желает изменить направление отсчета углов, используя команду UNITS или системные переменные ANGBASE и A</font>NGDIR.</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">GETRIENT похожа на GETANGLE-функцию, но отличается от нее тем, что измеряет углы в градусах и направление отсчета углов определяется другим способом, чем в GETANGLE. GETANGLE используется, если вам необходим суммарный угол (относительный угол), в то время как GETORIENT используется для достижения ориентации (абсолютный угол).</P>
<P ALIGN="JUSTIFY">Предположим, что была использована команда AutoCADa UNITS для выбора отсчета в градусах и нулевое направление -90 (север), отсчет градусов в направлении часовой стрелки. В таблице указаны значения, которые возвращают GETANGLE и GETORIENT (в радианах), если пользователем введены указанные значения (в градусах):</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=496>
<TR><TD WIDTH="38%" VALIGN="TOP" HEIGHT=22>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Введено (градусы)</FONT></TD>
<TD WIDTH="29%" VALIGN="TOP" HEIGHT=22>
<P ALIGN="JUSTIFY">GETANGLE</TD>
<TD WIDTH="33%" VALIGN="TOP" HEIGHT=22>
<P ALIGN="CENTER">GETORIENT</TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<P ALIGN="CENTER">0</TD>
<TD WIDTH="29%" VALIGN="TOP">
<P ALIGN="CENTER">0.000000</TD>
<TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">1.570796</TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<P ALIGN="CENTER">-90</TD>
<TD WIDTH="29%" VALIGN="TOP">
<P ALIGN="CENTER">1.570796</TD>
<TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">3.141593</TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<P ALIGN="CENTER">180</TD>
<TD WIDTH="29%" VALIGN="TOP">
<P ALIGN="CENTER">3.141593</TD>
<TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">4.712389</TD>
</TR>
<TR><TD WIDTH="38%" VALIGN="TOP">
<P ALIGN="CENTER">90</TD>
<TD WIDTH="29%" VALIGN="TOP">
<P ALIGN="CENTER">4.712389</TD>
<TD WIDTH="33%" VALIGN="TOP">
<P ALIGN="CENTER">0.000000</TD>
</TR>
</TABLE>
<p></P>

<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Как видно из таблицы, GETANGLE предпочитает направление приращения угла, но игнорирует направление нуля градусов. Так, вы можете использовать GETANGLE при повороте вставляемого блока, т.к. введение нуля градусов будет всегда возвращать ноль радиан. С другой стороны, GETORIENT воспринимает как направление нуля градусов, так и направление приращения угла. Так, вы можете использовать GETORIENT для введения таких углов, как угол базовой линии для команды ТЕХТ. Например, указанная выше установка UNITS укажет направление базовой линии обычной горизонтальной строки текста на 90 градусов.</P>
<P ALIGN="JUSTIFY">Вы не можете ввести другое LISP-выражение в качестве ответа на запрос GETORIENT. Смотрите также GETANGLE и INITGET.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172685"><A NAME="_Ref465173478"><A NAME="_Toc465260927">(getpoint 
  [&lt;точка&gt;] [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Эта функция запрашивает от пользователя точку &lt;точка&gt;. Факультативный аргумент - базовая [&lt;точка&gt;] и [&lt;подсказка&gt;] - факультативная запись для высвечивания на экране в качестве подсказки. Вы можете ввести точку путем указания ее на экране или записав координаты в текущих</font> <FONT FACE="Times New Roman">единицах измерения. Если присутствует аргумент &lt;точка&gt;, AutoCAD нарисует "резиновую" линию от этой точки до текущего положения курсора.</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq p (getpoint))</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq p (getpoint "Where? "))                    /"Где? "/</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq p (getpoint '(1.5 2.0) "</font><FONT FACE="Courier New">Second point: "))  /"Вторая точка: "/</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Обычно, GETPOINT возвращает 2-х мерную точку (список из двух действительных чисел). Используя функцию INIGET для установки контрольного символа "3-х мерная точка", вы можете заставить GETPOINT возвращать 3-х мерную точку (список из трех действительных чисел).</P>
<P ALIGN="JUSTIFY">Вы не можете ввести иное LISP-выражение в ответ на запрос GETPOINT. Смотрите также GETCORNER и INITGET.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172686"><A NAME="_Ref465173479"><A NAME="_Toc465260928"> 
  (getreal [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  запрашивает пользователя ввести действительное число и  возвращает его. &lt;Подсказка&gt;- необязательный аргумент для высвечивания на  экране в виде подсказки.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq val (getreal))</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq val (geyrial "Scale factor: "))    /"Масштабный фактор: "/</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Вы не можете ввести иное LISP-выражение в ответ на запрос GETREAL. Смотрите также INITGET.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172687"><A NAME="_Ref465173480"><A NAME="_Toc465260929">(getstring 
  [&lt;cr&gt;] [&lt;подсказка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция запрашивает пользователя ввести строковую константу и возвращает этот константу. Если &lt;cr&gt; присутствует и не nil, вводимый поток может содержать пробелы (и должен, следовательно, оканчиваться RETURN). Иначе ввод текста (строковой константы) будет прерван пробелом RETURN. &lt;Подсказка&gt; - факультативный аргумент для высвечивания на экране в виде подсказки.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY"> (setq s (getstring))</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New"> (setq s (getstring "What's your fist name? "))   /"Ваше имя?</font><FONT FACE="Courier New"> "/</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY"> (setq s (getstring T "What's your full name? ")) /"Ваше полное имя? "/</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY"> </P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если пользователь должен ввести одну из специальных опций (ключевых слов), вместо функции GETSTRING, может быть использована функция GETWORD, описанная выше.</P>
<P ALIGN="JUSTIFY">Вы не можете ввести иное LISP-выражение как ответ на запрос GETSTRING.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172688"><A NAME="_Ref465173481"><A NAME="_Toc465260930">(getvar 
  &lt;имя переменной&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает значение системной переменной AutoCADa. Имя переменной должно быть заключено в кавычки ("имя").</P>
<P ALIGN="JUSTIFY">Например, предположим, что радиус сопряжения был недавно определен в 0.25 единиц:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(getvar "FILLETRAD")</font><FONT FACE="Times New Roman">&#9;возвращает&#9;0.250000</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если вы используете GETVAR с неизвестным AutoCADу именем переменной, функция возвратит nil. Список текущих системных переменных AutoCADa можно найти в приложении А руководства по AutoCADу. Смотрите также функцию SETVAR.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"> <A NAME="_Toc465172689"><A NAME="_Ref465173482"><A NAME="_Toc465260931">(graphscr)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  переключает экран с текстового режима в графический в  системах с одним экраном (также как функциональная клавиша "FLIP SCREEN"  в AutoCADe). GRAPHSCR всегда возвращает nil. Смотрите так же функцию  TEXTSCR.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172690"><A NAME="_Ref465173486"><A NAME="_Toc465260932">(if 
  &lt;текст-выражение&gt; &lt;выражение-тогда&gt; [&lt;выражение-иначе&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  исполняет выражение по условию. Если &lt;тест-выражение&gt;  не nil, тогда исполняется &lt;выражение-тогда&gt;, иначе исполняется  &lt;выражение-иначе&gt;. Последнее выражение &lt;выражение-иначе&gt; не обязательно.  IF возвращает значение выбранного выражения; если &lt;выражение-иначе&gt;  отсутствует и &lt;тест-выражение&gt; nil, IF возвращает nil.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(if (= 1 3) "Yes!!" "no.")&#9;</font><FONT FACE="Times New Roman">возвращает&#9;"no."</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(if (= 2 (+ 1 1) "Yes!!")&#9;</font><FONT FACE="Times New Roman">возвращает&#9;"Yes!</FONT>!"</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(if (= 2 (+ 3 4) "Yes!!")&#9;</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172691"><A NAME="_Ref465173487"><A NAME="_Toc465260933">(initget 
  [&lt;биты&gt;] [&lt;строка&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция   устанавливает различные опции для использования  последующими функциями GETxxx (кроме GETSTRING и GETVAR). INITGET всегда  возвращает nil. &lt;Биты&gt; - факультативный аргумент - целое число со следующими значениями </P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=779>
<TR><TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">INIGET биты</FONT></TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Значения</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P>Запрещен ввод недействительных чисел</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">2</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Запрещен ввод 0</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Запрещен ввод отрицательных чисел</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">8</TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Не контролируются пределы, даже при включенном </font>LIMCHECK</TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">16</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Возвращение 3-х мерных точек, предпочтительнее, чем 2-х мерных точек</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">32</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Применяется пунктир для изображения "резиновой" линии или рамки</FONT></TD>
</TR>
</TABLE>
</CENTER><p></P>

<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Биты могут добавляться вместе в любой комбинации, чтобы сформировать значение от 0 до 63. (Последующие версии AutoLISPа могут включать дополнительные контрольные биты, так что избегайте указывать незадокументированные биты).</P>
<P ALIGN="JUSTIFY">Если пользователь, вводя, забыл одно или более заданных условий (так, например, ввел 0, когда ввод 0 запрещен), AutoCAD высветит ошибку и предложит пользователю повторить ввод.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(initget (+ 1 2 4))</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq age (getint "How old are you? "))    /"Сколько Вам лет? "/</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">спросит возраст пользователя, автоматически повторяя запрос, если пользователь ответил пустым вводом, ввел отрицательное или нулевое значение. Если нет аргумента &lt;биты&gt;, подразумевается 0 (нет условий). Специальные контрольные значения обеспечиваются теми GETxxx функциями, для которых они имеют смысл, как показано в следующей таблице.</P>
<P ALIGN="JUSTIFY">Контрольный бит со значением 32 воспринимается функциями GETPOINT, GETCORNER, GETDIST, GETANGLE и GETORIENT когда присутствует аргумент &lt;базовая точка&gt;, и устанавливает режим использования пунктирной (или по-другому подсвеченной) линии в качестве "резиновой" линии или рамки, отрисовываемых курсором от заданной базовой точки. Если системная переменная POPUPS равна нулю, указывая тем самым, что драйвер дисплея не поддерживает улучшенный интерфейс пользователя, то AutoCAD проигнорирует этот бит функции INITGET.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=824>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функции </FONT></TD>
<TD WIDTH="82%" VALIGN="TOP" COLSPAN=5>
<P ALIGN="CENTER"><FONT FACE="Times New Roman">Контрольные биты </font>INITGET <FONT FACE="Times New Roman">воспринимаются</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Не пустой</FONT></TD>
<TD WIDTH="7%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Не 0</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Не отриц.</FONT></TD>
<TD WIDTH="17%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Нет пределов</FONT></TD>
<TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Использовать пунктир</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETING</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETREAL</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETDIST</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETANGL</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETORIENT</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETCORNER</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="17%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="32%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETKWORD</TD>
<TD WIDTH="13%" VALIGN="TOP">
<P ALIGN="CENTER">*</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETSTRING</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">&nbsp;</TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<P ALIGN="JUSTIFY">GETVAR</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="7%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="13%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="17%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="32%" VALIGN="TOP">&nbsp;</TD>
</TR>
</TABLE>

<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Факультативный аргумент INITGET-функции &lt;строка&gt; определяет список ключевых слов, которые будут проверяться в последующем запросе GETxxx, если пользователь произвел ввод неправильного типа (например, точку для GETPOINT). Если ввод пользователя соответствует одному из ключевых слов из этого списка, это ключевое слово возвращается GETxxx функцией как результат типа STRING (строковая константа). Программа пользователя может тестировать ключевые слова и выполнять желаемые действия для каждого из них. Если ввод пользователя недозволенного типа и не соответствует ни одному из ключевых слов, AutoCAD предложит пользователю повторить ввод.</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Список ключевых слов может быть такой формы :"Key1 KEy2 KEY3,ABBREV3". Отдельные ключевые слова отделяются пробелами. Сокращение необязательно и возможны два способа специфицирования. Необходимая для ввода часть ключевого слова может быть выделена заглавными буквами, остальная часть строчными или необходимая часть может быть повторена через запятую после ключевого слова. Второй способ применяется в случае использования иностранного языка, где переход из прописных в заглавные буквы сложен или невозможен . В обоих случаях длина необходимой части - минимальная длина, которая должна быть для точного различения. (Для метода с разделением запятой подразумевается, что сокращение - это начало ключевого</font> <FONT FACE="Times New Roman">слова.)</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Например</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">"LTYPE,LT"</font><FONT FACE="Times New Roman">   и              </FONT><FONT FACE="Courier New">"LType"</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">эквивалентные спецификации. Будет восприниматься любой ввод пользователя  из "LTYPE", "LTYP", "LTY" или "LT", но "L" недостаточно, не подходят и  "LTSCALE" "LTYPEX".</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Рассмотрим следующую функцию, определенную пользователем:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">            (defun getnum (/ x)</P>
<P ALIGN="JUSTIFY">               (initget 1 "Pi Two-pi")</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">               (setq x (getreal "pi/Two-pi/&lt;число&gt;:"))</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">               (cond ((eq x "Pi")    pi)</P>
<P ALIGN="JUSTIFY">                     ((eq x "Two-pi:") (* 2.0 pi))</P>
<P ALIGN="JUSTIFY">                     (T                x)</P>
<P ALIGN="JUSTIFY">                   )</P>
<P ALIGN="JUSTIFY">                )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Здесь INITGET препятствует пустому вводу и устанавливает список из двух ключевых слов "Pi" и "Two-pi". Затем используется GETREAL для извлечения вещественного числа с помощью подсказки "Pi/Two-pi/&lt;число&gt;:" и результат помещается в локальный символ Х. Если пользователь вводит число, это число возвращается функцией GETNUM. Однако, если пользователь вводит ключевое слово "Pi" (или просто "P"), GETPOINT возвращает ключевое слово "Pi". Функция</font> <FONT FACE="Times New Roman">COND фиксирует это и в этом случае возвращает значение pi. Ключевое слово "Two-pi" трактуется аналогично.</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Список управляющих сигналов и ключевых слов, устанавливаемые INITGET, применимы только к следующему за INITGET вызываемому GETxxx и затем автоматически сбрасываются. Это позволяет Getxxx-функций избежать необходимости при следующем вызове очищать специальные состояния.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172692"><A NAME="_Ref465173488"><A NAME="_Toc465260934">(insers 
  &lt;точка1&gt; &lt;точка2&gt; &lt;точка3&gt; &lt;точка4&gt; [&lt;onseg&gt;])</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Функция INTERS проверяет два отрезка на пересечение и возвращает точку пересечения или nil, если они не пересекаются. &lt;Точка1&gt; и &lt;точка2&gt; крайние точки первого отрезка, &lt;точка3&gt; &lt;точка4&gt; - крайние точки второго отрезка. Если факультативный аргумент &lt;onseg&gt; присутствует и является nil, то отрезки будут восприниматься бесконечной длины и INTERS будет возвращать точку пересечения даже, если она находится за крайними точками одного или обоих отрезков. Если же аргумент &lt;onseg&gt; отсутствует или не является nil, то точка пересечения должна находится на обоих отрезках или INTERS вернет ni</font>l.</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a '(1.0 1.0) b '(9.0 9.0))</P>
<P ALIGN="JUSTIFY">(setq c '(4.0 1.0) c '(4.0 2.0))</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(inters a b c d)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">inters a b c d T)&#9;</FONT><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">inters a b c d nil)</FONT><FONT FACE="Times New Roman">&#9;возвращает (4.000000 4.000000)</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172693"><A NAME="_Ref465173489"><A NAME="_Toc465260935">(itoa 
  &lt;целое&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает преобразование целого числа в строковую константу.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(itoa 33)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;"33"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(itoa -17)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"-17"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172694"><A NAME="_Ref465173492"><A NAME="_Toc465260936">(lambda 
  &lt;аргументы&gt; &lt;выражение&gt; ...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция определяет "анонимную" функцию. Она обычно используется, когда при определении новая функции не именуется. Это так же делает замысел программиста более очевидным, за счет того, что функция находится там же, где она используется. LAMBDA возвращает значение последнего &lt;выражения&gt; и часто используется в связи с APPLY и/или MAPCAR для выполнения функции над списком.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(apply '(lambda (x y z)</P>
<P ALIGN="JUSTIFY">         (* x (-y z))</P>
<P ALIGN="JUSTIFY">            )</P>
<P ALIGN="JUSTIFY">         '(5 20 14)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">     )&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;30</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">и:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(mapcar '(lambda (x)</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">                   (setq counter (1+ counter))</P>
<P ALIGN="JUSTIFY">            (* x 5)</P>
<P ALIGN="JUSTIFY">               )</P>
<P ALIGN="JUSTIFY">            '(24 -6 10.2)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">       )&#9;&#9;</font><FONT FACE="Times New Roman">возвращает (10 20 -30 51.000000)</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172695"><A NAME="_Ref465173493"><A NAME="_Toc465260937">(last 
  &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает последний элемент списка. &lt;Список&gt; не должен быть  равен nil. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(last '(a b c d e))</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;E</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(last '(a b c (d e)))</font><FONT FACE="Times New Roman">&#9;возвращает (D E)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Как видно, LAST возвращает либо атом, либо список.</P>
<P ALIGN="JUSTIFY">На первый взгляд LAST может являться хорошим путем для извлечения координаты Y точки. Хотя это так для 2-х мерных точек (список из 2-х действительных чисел). LAST будет возвращать координату Z в случае 3-х мерной точки. Чтобы ваши функции работали, как следует при задании и 2-х мерных и 3-х мерных точек, мы рекомендуем вам использовать CADR для извлечения координаты Y и CADDR для извлечения координаты Z.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172696"><A NAME="_Ref465173494"><A NAME="_Toc465260938">(length 
  &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает целое число, означающее число элементов в  &lt;списке&gt;. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(length '(a b c d))</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;4</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(length '(a b (c d)))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(length '())</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает&#9;0</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172697"><A NAME="_Ref465173495"><A NAME="_Toc465260939"> 
  (list &lt;выражение&gt; ...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  берет любое число выражений (&lt;выражение&gt;) и организует из  них строку, возвращая список.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(list 'a 'b 'c)</font><FONT FACE="Times New Roman">&#9;возвращает (A B C)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(list 'a '(b c) 'd)</font><FONT FACE="Times New Roman">&#9;возвращает (A (B C) D)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(list 3.9 6.7) &#9;</font><FONT FACE="Times New Roman">возвращает (3.90000 6.70000)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В AutoLISP эти функции часто используются для определения значений  2-х и 3-х мерных точек (список из 2-х или 3-х действительных чисел).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172698"><A NAME="_Ref465173496"><A NAME="_Toc465260940">(listp 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает T, если &lt;элемент&gt; список, иначе nil.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(listp '(a b c))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(listp 'a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(listp 4.343)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172699"><A NAME="_Ref465173501"><A NAME="_Toc465260941">(load 
  &lt;имя файла&gt;)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Эта функция загружает файл выражений AutoLISPа и выполняет эти выражения. &lt;Имя файла&gt; - это строковая константа, которая представляет собой имя файла без расширения (подразумевается расширение ".lsp"). &lt;Имя файла&gt; может включать префикс директории, например "</font>/<FONT FACE="Times New Roman">function/test1". На системах MS-DOS/PS-DOS допускается так же использовать букву устройства ввода/вывода и вы можете пользоваться обратной косой чертой вместо прямой косой черты (но помните, чтобы ввести в строку одну обратную черту вы должны использовать</FONT> "\\").</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если операция успешно завершена, LOAD возвращает имя последней функции, определенной в файле. Если операция не выполнена, LOAD возвращает имя файла в виде строкового выражения.</P>
<P ALIGN="JUSTIFY">Например, предположим, что файл "/fred/test1.lsp" содержит DEFUN, определяющую функцию MY-FUNC, и что файл "test2.lsp" не существует:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(load "/fred/test1")</font><FONT FACE="Times New Roman">&#9;возвращает&#9;MY-FUNC</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(load "test2")</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает&#9;"test2"</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция LOAD не может вызываться из другой функции LISP. Она должна вызываться непосредственно с клавиатуры (или из меню или скрипт-файла), в то время как ни одна другая функция LISP не находится в процессе выполнения.</P>
<P ALIGN="JUSTIFY">Каждый раз, когда Редактор Чертежей AutoCAD начинает очередной сеанс, AutoLISP загружает файл "acad.lsp", если он существует. Вы можете поместить определения функций и часто используемые команды в этот файл, и они будут исполняться автоматически, когда вы будете редактировать чертежи.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172700"><A NAME="_Ref465173502"><A NAME="_Toc465260942">(log 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает натуральный логарифм &lt;числа&gt; как  действительное число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(log 4.5)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;1.504077</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(log 1.22)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;0.198850</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172701"><A NAME="_Ref465173503"><A NAME="_Toc465260943">(logand 
  &lt;число&gt; &lt;число&gt; ...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает результат действия побитового И над списком  &lt;чисел&gt;. Эти &lt;числа&gt; должны быть целые и результат - так же целое число. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(logand 7 15 3)&#9;</font><FONT FACE="Times New Roman">возвращает&#9;3</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(logand 2 3 15)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;2</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(logand 8 3 4)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;0</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172702"><A NAME="_Ref465173504"><A NAME="_Toc465260944">(logior 
  &lt;число&gt; &lt;число&gt; ...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает результат действия побитового ИЛИ над списком  &lt;чисел&gt;. &lt;Числа&gt; должны быть целые и результат так же целое число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(logior 1 2 4)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;7</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(logior 9 3)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;11</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172703"><A NAME="_Ref465173505"><A NAME="_Toc465260945">(lsh 
  &lt;число1&gt; &lt;число бит&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает побитовый сдвиг &lt;числа1&gt; на &lt;число бит&gt;. &lt;Число1&gt; и &lt;число бит&gt; должны быть целыми и результат - тоже целое.</P>
<P ALIGN="JUSTIFY">Если &lt;число бит&gt; положительно, то &lt;число1&gt; сдвигается влево; если отрицательно - то вправо. В каждом случае "нулевые" биты добавляются, а сдвигаемые биты сбрасываются. Если "единичный" бит сдвигается в высший (16-й) разряд целого числа, знак числа меняется.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(lsh 2 1)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;4</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(lsh 2 -1)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;1</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(lsh 40 2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;160</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(lsh 16384 1)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;-32768</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172704"><A NAME="_Ref465173528"><A NAME="_Toc465260946">(mopcar 
  &lt;функция&gt; &lt;список1&gt;...&lt;списокn&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает результат выполнения &lt;функции&gt; над  отдельными элементами от &lt;списка1&gt; до &lt;списка n&gt; вводимыми как аргументы в &lt;функцию&gt;. Число &lt;списков&gt; должно соответствовать числу аргументов,  требующихся для &lt;функции&gt;.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(mapcar '1+ '(10 20 30))</font><FONT FACE="Times New Roman">&#9;&#9;возвращает (11 21 31)</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">это эквивалентно:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(1+ 10)</P>
<P ALIGN="JUSTIFY">(1+ 20)</P>
<P ALIGN="JUSTIFY">(1+ 30)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Кроме того, что MAPCAR возвращает список результатов. Так же:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(mapcar '+ '(10 20 30) '(4 3 2))</font><FONT FACE="Times New Roman">&#9;возвращает (14 23 32)</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">это то же самое, что и:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(+ 10 4)</P>
<P ALIGN="JUSTIFY">(+ 20 3)</P>
<P ALIGN="JUSTIFY">(+ 30 2)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция LAMBDA может задавать "анонимную" функцию для выполнения функцией  MAPCAR. Это полезно когда некоторые из аргументов функции константы или передаются каким-либо иным образом.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(mapcar '(lambda (x) (+ x 3)) '(10 20 30))</font><FONT FACE="Times New Roman">&#9;возвращает&#9;(13 23 33)</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">и:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY"> (mapcar '(lambda (x y z)</P>
<P ALIGN="JUSTIFY">           (* x (- y z))</P>
<P ALIGN="JUSTIFY">             )</P>
<P ALIGN="JUSTIFY">          '(5 6) '(20 30) '(14 5.0)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">     )</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;(30 150.0</FONT>00000)</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172705"><A NAME="_Ref465173530"><A NAME="_Toc465260947">(max 
  &lt;число&gt; &lt;число&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает наибольшее из заданных &lt;чисел&gt;. Каждое &lt;число&gt; может быть действительным или целым. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(max 4.07 -144)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;4.070000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(max -88 19 5 2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;19</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172706"><A NAME="_Ref465173531"><A NAME="_Toc465260948">(member 
  &lt;выражение&gt; &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция просматривает &lt;список&gt; - встречается ли &lt;выражение&gt;  и  возвращает часть &lt;списка&gt;, начинающуюся с первого найденного &lt;выражения&gt;. Если в &lt;списке&gt; нет &lt;выражения&gt;, MEMBER возвращает nil.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">member 'c '(a b c d e))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;(C D </FONT>E)</P>
<P ALIGN="JUSTIFY">(<FONT FACE="Courier New">member 'q '(a b c d e))</FONT><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172707"><A NAME="_Ref465173532"><A NAME="_Toc465260949">(menucmd 
  &lt;строка&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  дает возможность LISP-программам переключаться среди  подстраниц в меню AutoCAD . Таким образом, LISP-программа может  согласованно работать с загруженными файлами меню, высвечивая  соответствующие подменю в то время, когда требуется ввод пользователя.  MENUCMD всегда возвращает nil. Аргумент &lt;строка&gt; записывается в следующей  форме:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">раздел = подменю</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">где раздел  указывает раздел меню. Допустимые имена:</P>
</FONT><P ALIGN="JUSTIFY"></P><DIR>
<DIR>

<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">S &#9;для экранного (SCREEN) меню</P>
<P ALIGN="JUSTIFY">B&#9;для кнопочного (BUTTONS) меню</P>
<P ALIGN="JUSTIFY">I&#9;для пиктографического (ICON) меню</P>
<P ALIGN="JUSTIFY">P1-P10&#9;для падающего (POP) меню с 1 по 10</P>
<P ALIGN="JUSTIFY">Т1-Т4&#9;для меню планшета (TABLET) с 1 по 4</P>
<P ALIGN="JUSTIFY">А1&#9;для добавочного (AUX1) меню</P>
</FONT><P ALIGN="JUSTIFY"></P></DIR>
</DIR>

<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">подменю указывает, какое подменю активизировать. Именем должна быть либо одна из меток подменю (без "**") в текущем загруженном файле или имя одного из разделов Главного меню.</P>
<P ALIGN="JUSTIFY">Для дальнейшей информации смотрите Приложение Б Руководства AutoCAD.  Заметим, что используемый для ссылки на подменю знак "$" в файле меню  здесь не используется.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(menucmd "S=OSNARP")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">будет означать, что подменю "OSNAP" появится на экране (имеется  в виду, что такое подменю существует в текущем файле меню).</P>
<P ALIGN="JUSTIFY">Так же:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(menucmd "B=MY-BUTTONS")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">будет присваивать подменю "MY-BUTTONS" кнопочному меню.</P>
<P ALIGN="JUSTIFY">Что касается пиктографических и падающих меню, то для них допустимо  имя подменю "*" и означает оно высвечивание подменю из текущего раздела  меню.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(menucmd "P1=NUMERIC")</P>
<P ALIGN="JUSTIFY">(menucmd "P1=*")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">выберет подменю "NUMERIC" из падающего меню 1 и высветит его на экране.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">MENUCMD всегда возвращает nil.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172708"><A NAME="_Ref465173533"><A NAME="_Toc465260950">(min 
  &lt;число&gt; &lt;число&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает наименьшее из заданных &lt;чисел&gt;. Каждое &lt;число&gt; может быть действительным или целым.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(min 683 -10.0)&#9;</font><FONT FACE="Times New Roman">возвращает-10.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(min 73 2 48 5)&#9;</font><FONT FACE="Times New Roman">возвращает2</font></P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172709"><A NAME="_Ref465173534"><A NAME="_Toc465260951">(minusp 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает T, если &lt;элемент&gt; действительное или целое  число имеющее отрицательное значение, иначе она возвращает nil. Она не определена для других типов &lt;элементов&gt;.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(minus -1)&#9;</font><FONT FACE="Times New Roman">возвращает</FONT>&#9;T</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(minusp -4.293)&#9;</font><FONT FACE="Times New Roman">возвращает</FONT>&#9;T</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(minusp 830.2)&#9;</font><FONT FACE="Times New Roman">возвращает</FONT>&#9;nil</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172710"><A NAME="_Ref465173535"><A NAME="_Toc465260952">(not 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает Т, если выражение - nil, иначе nil. Обычно функция NULL используется для списков, а NOT для других типов данных в связи с каким-либо типом управляющих функций.</P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 123)</P>
<P ALIGN="JUSTIFY">(setq b "string")</P>
<P ALIGN="JUSTIFY">(setq c nil)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(not a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(not b)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(not c)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(not '())</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172711"><A NAME="_Ref465173538"><A NAME="_Toc465260953">(nth 
  &lt;n&gt; &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает "энный" элемент &lt;списка&gt;, где &lt;n&gt; - номер  элемента (ноль - первый элемент). Если &lt;n&gt; больше, чем номер последнего  элемента &lt;списка&gt;, возвращается nil.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(nth 3 '(a b c d e))&#9;</font><FONT FACE="Times New Roman">возвращает&#9;D</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(nth 0 '(a b c d e))&#9;</font><FONT FACE="Times New Roman">возвращает&#9;A</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(nth 5 '(a b c d e))&#9;</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"> <A NAME="_Toc465172712"><A NAME="_Ref465173540"><A NAME="_Toc465260954">(null 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает Т, если &lt;элемент&gt; вычисляется в nil, иначе  nil. </P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 123)</P>
<P ALIGN="JUSTIFY">(setq b "string")</P>
<P ALIGN="JUSTIFY">(setq c nil)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(null a)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(null b</font><FONT FACE="Times New Roman">)&#9;&#9;возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(null c)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(null '())&#9;</font><FONT FACE="Times New Roman">возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172713"></A><A NAME="_Ref465173541"></A><A NAME="_Toc465260955"></A><FONT FACE="Arial">(number</font><FONT FACE="Arial">p 
  &lt;элемент&gt;)</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает Т, если &lt;элемент&gt; - целое или действительное число,  иначе nil.</P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 123)</P>
<P ALIGN="JUSTIFY">(setq b 'a)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp 4)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp 3.8348)&#9;</font><FONT FACE="Times New Roman">возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp "Howdy")&#9;</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp 'a)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp a)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp b)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(numberp (eval b))&#9;</font><FONT FACE="Times New Roman">возвращает&#9;T</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172714"><A NAME="_Ref465173543"><A NAME="_Toc465260956"> 
  (open &lt;имя файла&gt; &lt;режим&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  открывает файл для доступа функций Ввода/Вывода (I/O) AutoLISP. Она возвращает описатель файла для использования другими функциями Ввода/Вывода, поэтому она должна присваиваться функцией SETQ</P>
<P ALIGN="JUSTIFY">символу.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a (open "file.ext" "r"))</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">&lt;имя файла&gt; - это строковая константа, указывающая имя и расширение  открываемого файла. &lt;Режим&gt; - это флаг чтения/записи. Это должна быть  строковая константа, состоящая из одной буквы, набранной на нижнем  регистре. Допустимые значения букв режима описываются в следующей таблице.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="RIGHT"><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=812>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER"><FONT FACE="Times New Roman">Режим </font>OPEN</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Описание</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">"r"</TD>
<TD WIDTH="85%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Открыть для чтения. Если &lt;имя файла&gt;  не существует, возвращается nil.</FONT></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<P ALIGN="CENTER">"w"</TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Открыть для записи. Если &lt;имя файла&gt;  не существует, создается новый файл и открывается. Если &lt;имя файла</font>&gt; <FONT FACE="Times New Roman">уже существует, находящиеся в нем данные будут перезаписаны. </font></P>
<P ALIGN="JUSTIFY"></TD>
</TR>
<TR><TD WIDTH="15%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">"а"</FONT></TD>
<TD WIDTH="85%" VALIGN="TOP">
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Открыть для добавления. Если &lt;имя файла&gt; не существует, создается новый файл и открывается. Если &lt;имя файла&gt; уже существует, он будет открыт и помещен таким образом, что любые новые данные будут записываться в файл вслед за уже существующими. В системах DOS некоторые программы и текстовые  редакторы записывают текстовые файлы с маркером конца файла (CTRL Z, десятичный код ASCII 26) в конце текста. Читая текстовый файл, DOS возвращает состояние конца  файла, если встретит маркер CTRL Z, даже если после  маркера присутствуют еще данные. Если вы намерены использовать режим "а" функции </font>O<FONT FACE="Times New Roman">PEN для добавления данных в файлы, созданные другими программами, удостоверьтесь, что другая программа не вставила маркеры CTRL Z в конце своих текстовых файлов.         </font></P>
<P ALIGN="JUSTIFY"></TD>
</TR>
</TABLE>
<p></P>

<P ALIGN="JUSTIFY">&nbsp;</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Предположим, что поименованные файлы в следующем примере не существуют:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq f (open "new.tst" "w"))&#9;&#9;</font><FONT FACE="Times New Roman">возвращает &lt;File #nnn&gt;</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq f (open "nosuch.fil" "r"))&#9;</font><FONT FACE="Times New Roman">возвращает nil</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq f (open "longfile" "a"))&#9;</font><FONT FACE="Times New Roman">возвращает &lt;File #nnn&gt;</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">&lt;имя файла&gt; может включать префикс директории, как, например,  "/test/func3". На системах MS-DOS/PS-DOS допускается так же использовать  букву устройства ввода/вывода и вы можете пользоваться обратной косой  чертой вместо прямой косой черты (но помните, чтобы ввести в строку  одну обратную черту вы должны использовать "\\").</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq f (open "new.tst" "w"))&#9;&#9;</font><FONT FACE="Times New Roman">возвращает &lt;File #nnn&gt;</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq f (open "nosuch.fil" "r"))&#9;</font><FONT FACE="Times New Roman">возвращает nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172715"><A NAME="_Ref465173544"><A NAME="_Toc465260957">(or 
  &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает логическое ИЛИ списка выражений. OR оценивает выражения слева направо до тех пор, пока не встретится выражение, вычисляемое не в nil. Если такое найдено, OR прекращает дальнейшую оценку и возвращает T. Если все выражения nil, OR возвращает nil.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(or nil 45 '())&#9;</font><FONT FACE="Times New Roman">возвращает Т.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(or nil '())&#9;&#9;</font><FONT FACE="Times New Roman">возвращает nil.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172716"><A NAME="_Ref465173545"><A NAME="_Toc465260958">(osnap 
  &lt;точка&gt; &lt;строка-режим&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает точку, которая является результатом применения объектной привязки, задаваемой в &lt;строке-режим&gt; для точки &lt;точка&gt;. &lt;строка-режим&gt; - строковая константа, состоящая из одного или более идентификаторов объектной привязки, как, например, "midpoint", "center" и т.д., разделенных запятыми.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq pt2 (osnap pt1 "midp"))</P>
<P ALIGN="JUSTIFY">(setq pt2 (osnap pt1 "midp,endp,center"))</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если аргумент &lt;точка&gt; - 2-х мерная точка (список из двух действительных чисел), то будет возвращена 2-х мерная точка. Если аргумент &lt;точка&gt; - 3-х мерная точка (список из трех действительных чисел), то будет возвращена 3-х мерная точка. Если ни одной точки, соответствующей заданному &lt;режиму&gt; объектной привязки не найдено, будет возвращаться nil.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172717"><A NAME="_Ref465173547"><A NAME="_Toc465260959"> 
  pi</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Это не функция, это константа pi. Ее значение принято 3.1415926.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172718"><A NAME="_Ref465173548"><A NAME="_Toc465260960">(polar 
  &lt;точка&gt; &lt;угол&gt; &lt;расстояние&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  возвращает точку, находящуюся под углом &lt;угол&gt; и на расстояние &lt;расстояние&gt; от заданной &lt;точки&gt;. Точки - список двух действительных чисел и &lt;угол&gt; выражается в радианах.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(polar '(1.0 1.0) 0.785398 1.414214)</font><FONT FACE="Times New Roman">&#9;возвращает (2.000000 2.000000)</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172719"><A NAME="_Ref465173549"><A NAME="_Toc465260961">(prin1 
  &lt;выражение&gt; [&lt;описатель файла&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция выводит выражение &lt;выражение&gt; на экран и возвращает &lt;выражение&gt;. &lt;выражение&gt; может быть любым выражением; не требуется, чтобы оно было строковой константой. Если присутствует &lt;описатель файла&gt; (и является описателем файла, открытого для записи), &lt;выражение&gt; записывается в файл в то время, как оно появляется на экране. Печатается только указанное &lt;выражение&gt;; не включается никаких пробелов и переходов на новую строку.</P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 123)</P>
<P ALIGN="JUSTIFY">(setq b '(a))</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(prin1 'a)</font><FONT FACE="Times New Roman">&#9;&#9;печатает А&#9;&#9;и&#9;&#9;возвращает А</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(prin1 a)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;печатает 123&#9;&#9;и&#9;возвращает 123</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(prin1 b)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;печатает (А)&#9;&#9;и&#9;возвращает (А)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(prin1 "Hello")</font><FONT FACE="Times New Roman">&#9;печатает "hello"&#9;и&#9;возвращает "Hell</FONT>o"</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Каждый из выше приведенных примеров печатается на экране, т.к. не был указан &lt;описатель файла&gt;. Предположим, что F - допустимый описатель файла для файла, открытого для записи:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(prin1 "Hello" f)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">запишет "Hello" в указанный файл и возвратит "Hello".</P>
<P ALIGN="JUSTIFY">Если &lt;выражение&gt; - это строковая константа, включающая управляющие символы, PRIN1 интерпретирует эти символы, как следующие, добавляя перед ними знак "\":</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">\е&#9;для выхода (escape)</P>
<P ALIGN="JUSTIFY">\n&#9;для перехода на новую строку (newline)</P>
<P ALIGN="JUSTIFY">\r&#9;для ввода (return)</P>
<P ALIGN="JUSTIFY">\t&#9;для табуляции (tab)</P>
<P ALIGN="JUSTIFY">\nnn&#9;для символа, восьмеричный код которого nnn.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">так:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(prin1 (chr 2))</font><FONT FACE="Times New Roman">&#9;печатает "\002" и возвращает "\002"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(prin1 (chr 10))</font><FONT FACE="Times New Roman">&#9;печатает "\n" и возвращает "\n"</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">PRIN1 может использоваться и без аргументов, тогда она возвращает (и печатает) символ, называемый пустой строкой символов. Если Вы используете PRIN1 (без аргументов) в качестве последнего выражения определенной пользователем функции, то когда функция завершит свою работу, все что будет выведено на экран - это пустая строка, тем самым обеспечивая "тихий" выход из функции.</P>
<P ALIGN="JUSTIFY">Например, пусть:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(defun C:SETUP ()</P>
<P ALIGN="JUSTIFY">(setvar "LUNITS" 4)</P>
<P ALIGN="JUSTIFY">(setvar "BLIPMODE" 0)</P>
<P ALIGN="JUSTIFY">(prin1)</P>
<P ALIGN="JUSTIFY">   )</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">Command:SETUP</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">исполнит определенную пользователем команду, отвечая на запросы функции SETVAR, и вернется к подсказке AutoCADа "Command:", не выводя на экран никаких лишних сообщений.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172720"><A NAME="_Ref465173552"><A NAME="_Toc465260962">(princ 
  &lt;выражение&gt; [&lt;описатель файла&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  похожа на PRIN1 кроме того, что управляющие символы в &lt;выражении&gt; печатаются без расширения. Вообще PRIN1 создана для печати  выражений путем, совместимым с функцией LOAD, в то время как PRINC будет печатать их таким путем, чтобы они могли считываться функциями типа READ-LINE.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172721"><A NAME="_Ref465173553"><A NAME="_Toc465260963">(print 
  &lt;выражение&gt; [&lt;описатель файла&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  похожа на PRIN1, кроме того что &lt;выражение&gt; печатается с новой строки, а после &lt;выражения&gt; ставится пробел.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172722"><A NAME="_Ref465173554"><A NAME="_Toc465260964">(progn 
  &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  вычисляет каждое &lt;выражение&gt; последовательно и возвращает значение последнего выражения. Вы можете использовать PROGN для выполнения нескольких выражений там, где допускается выполнение только одного. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(if (= a b) (progn</P>
<P ALIGN="JUSTIFY">             (setq a (+ a 10))</P>
<P ALIGN="JUSTIFY">             (setq b (- b 10))</P>
<P ALIGN="JUSTIFY">                )</P>
<P ALIGN="JUSTIFY">    )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция IF нормально выполняет одно выражение "then" /тогда/, если условие выполняется и не равно nil. В этом примере мы использовали PROGN, чтобы выполнялось два выражения вместо одного.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172723"><A NAME="_Ref465173555"><A NAME="_Toc465260965"> 
  (prompt &lt;сообщение&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция  высвечивает сообщение в поле подсказок экрана и возвращает nil. &lt;сообщение&gt; - строка символов. В системе AutoCAD с двумя экранами PROMT высвечивает &lt;сообщение&gt; на обоих экранах и поэтому предпочтительно использовать PRINC.</P>
<P ALIGN="JUSTIFY"> Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(prompt "Новое значение: ")</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">высвечивает "Новое значение: " на экране (экранах) и возвращает nil.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172724"><A NAME="_Ref465173556"><A NAME="_Toc465260966">(quote 
  &lt;выражение&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Возвращает выражение не выполняя его. Это может быть так же записано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">'выражение</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(quote a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает А</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(quote сat</font><FONT FACE="Times New Roman">)&#9;возвращает CАT</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(quote (a b))</font><FONT FACE="Times New Roman">&#9;возвращает (А B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">'a</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает А</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">'cat</font><FONT FACE="Times New Roman">&#9;&#9;&#9;возвращает CАT</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">'(a b)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает А</font></P>
<P ALIGN="JUSTIFY"></P>
<B><U><FONT FACE="Times New Roman" SIZE=4 COLOR="#800000">
<P ALIGN="JUSTIFY"><font color="#006666">(Последние три примера не будут работать, 
  если их набрать непосредственно с клавиатуры в ответ на запрос AutoCAD. Помните, 
  что такой ввод должен начинаться с "(" или "!" с целью интерпретации их как 
  выражений LISP.)</font></P>
</font></u></B><I><P ALIGN="JUSTIFY">&nbsp;</P>
<B><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172725"><A NAME="_Ref465173557"><A NAME="_Toc465260967">(read 
  &lt;строка&gt;)</A></A></A></P>
</font></B></I><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает первый список или атом из данной &lt;строки&gt;. &lt;строка&gt; не должна содержать пробелы.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(read "hello")</font><FONT FACE="Times New Roman">&#9;возвращает HELLO</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(read "hi")</font><FONT FACE="Times New Roman">&#9;возвращает HI</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(read "(a)")</font><FONT FACE="Times New Roman">&#9;возвращает (A)</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172726"><A NAME="_Ref465173558"><A NAME="_Toc465260968"> 
  (read-char [&lt;описатель файла&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция считывает единичный символ из буфера ввода клавиатуры или из открытого файла задаваемого &lt;описателем файла&gt;. Она возвращает (целое) ASCII код считываемого символа.</P>
<P ALIGN="JUSTIFY">Если не задано &lt;описателя файла&gt; и в буфере ввода клавиатуры нет символов, READ-CHAR ждет, чтобы вы ввели что-либо с клавиатуры (заканчивающееся RETURN).</P>
<P ALIGN="JUSTIFY">Например, допустим, что буфер клавиатуры пуст:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(read-char)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">будет ждать какого-либо ввода. Если вы набрали "АВС", завершив ввод RETURN, READ-CHAR возвратит 65 (код AS0CII буквы "А" (латинской)). Следующие три обращения к READ-CHAR возвратят 66,67 и 10 (переход на новую строку) соответственно. Если затем последует еще одно обращение к READ-CHAR, она будет ждать ввода.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172727"><A NAME="_Ref465173559"><A NAME="_Toc465260969">(read-line 
  [&lt;описатель файла&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция считывает строку символов с клавиатуры или из открытого файла, заданного &lt;описателем файла&gt;; READ-LINE возвращает nil, иначе она возвращает строковое значение, которое было считано. Например, допустим, что F - это разрешенный указатель открытого файла:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(read-line f)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">возвратит следующую введенную строку из файла или (если достигнут конец файла) nil.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172728"><A NAME="_Ref465173562"><A NAME="_Toc465260970"> 
  (redraw [&lt;имя примитива&gt; [&lt;режим&gt;]])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Действие функции зависит от числа введенных аргументов. Если она вызывается без аргументов:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(redrow)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">будет нарисован весь чертеж, точно так же, как это делает команда AutoCAD REDRAW. Если вызывается с аргументом &lt;имя примитива&gt;:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(redraw &lt;имя примитива&gt;)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">выбранный примитив будет перерисован. Это используется для   идентификации примитива на экране после использования функции GRCLEAR для очистки экрана. Имена примитивов описаны в главе 5 настоящего руководства. Полный контроль за перерисованием примитива обеспечивается вызовом REDRAW с двумя аргументами:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(redraw &lt;имя примитива&gt; &lt;режим&gt;)</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">где &lt;имя примитива&gt; - это имя перерисовываемого примитива, а &lt;режим&gt;- это целое число с одним из следующих значений:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=720>
<TR><TD WIDTH="25%" VALIGN="TOP">
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Режим </font>REDRAW</TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Действие </FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Перечерчивание примитива на экране</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<P ALIGN="CENTER">2</TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Не рисует примитив (стирает)</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<P ALIGN="CENTER">3</TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Подсвечивает примитив (если может дисплей)</FONT></TD>
</TR>
<TR><TD WIDTH="25%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
<TD WIDTH="75%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Перестает подсвечивать примитив ( если может дисплей )</FONT></TD>
</TR>
</TABLE>
</CENTER><p></P>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если &lt;имя примитива&gt; - заголовок сложного примитива (Полилинии или Блока с атрибутами), в процессе перерисовки будут участвовать как основной примитив, так и все подпримитивы, если аргумент &lt;режим&gt; положителен. Если же аргумент &lt;режим&gt; отрицателен, то только основной примитив будет участвовать в процессе REDRAW.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172729"></A><A NAME="_Ref465173563"></A><A NAME="_Toc465260971"></A><FONT FACE="Arial">(r</font><FONT FACE="Arial">em 
  &lt;число1&gt; &lt;число2&gt;)</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция делит &lt;число1&gt; на &lt;число2&gt; и возвращает остаток от деления (&lt;число1&gt; mod &lt;число2&gt;). REM может использоваться с целыми и действительными величинами со стандартными правилами преобразования.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rem 42 12)</font><FONT FACE="Times New Roman">&#9;возвращает</FONT> 6</P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rem 12.0 16)</font><FONT FACE="Times New Roman">&#9;возвращает 12.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rem 60 3)</font><FONT FACE="Times New Roman">&#9;возвращает 0</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172730"><A NAME="_Ref465173564"><A NAME="_Toc465260972">(repeat 
  &lt;число&gt; &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В этой функции &lt;число&gt; представляется любой положительной целой величиной. Функция выполняет каждое &lt;выражение&gt; заданное &lt;число&gt; раз и возвращает значение последнего выражения.</P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 10)</P>
<P ALIGN="JUSTIFY">(setq b 100)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(repeat 4</P>
<P ALIGN="JUSTIFY">(setq a (+ a 10)))</P>
<P ALIGN="JUSTIFY">(setq b (+ b 10)))</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">    )&#9;</font><FONT FACE="Times New Roman">возвращает 140.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172731"><A NAME="_Ref465173565"><A NAME="_Toc465260973"> 
  (reverse &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает &lt;список&gt; c его элементами, расставленными в обратном порядке.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(reverse '((a) b c))</font><FONT FACE="Times New Roman">&#9;возвращает (С В (А))</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172732"><A NAME="_Ref465173566"><A NAME="_Toc465260974">(rtos 
  &lt;число&gt; [&lt;режим&gt; [&lt;точность&gt;]])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает строковую константу, которая представляет &lt;число&gt; (действительная величина) в соответствии со значениями &lt;режима&gt;, &lt;точности&gt; и размерной переменной AutoCAD DIMZIN. &lt;Режим&gt; и &lt;точность&gt; - целые величины, которые назначают режим представления и его точность. Ниже представлены значения &lt;режима&gt;:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="LEFT"><TABLE BORDER CELLSPACING=1 CELLPADDING=9 WIDTH=602>
<TR><TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER"><FONT FACE="Times New Roman">Режимы </font>RTOS</TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="CENTER">Формат представления</FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">1</TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Научный</FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">2</TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Десятичный</FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">3</TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Инженерный (футы и десятичные дюймы)</FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">4</TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Архитектурный (футы и дробные дюймы)</FONT></TD>
</TR>
<TR><TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">5</TD>
<TD WIDTH="73%" VALIGN="TOP">
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Произвольные дробные части</FONT></TD>
</TR>
</TABLE>
<p></P>

<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Аргументы &lt;режим&gt; и &lt;точность&gt; соответствуют системным переменным AutoCAD  LUNITS и LUPREC. Если опустили эти аргументы, то будут использованы текущие значения LUNITS и LUPREC. </P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Примеры</font> RTOS:</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rtos 17.5 1 4)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"1.7500E+01"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rtos 17.5 2 2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"17.50"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rtos 17.5 3 2)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;"1'-5.50""</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rtos 17.5 4 2)&#9;</font><FONT FACE="Times New Roman">возвращает&#9;"1'-5 1/2""</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(rtos 17.5 5 2)&#9;</font><FONT FACE="Times New Roman">возвращает&#9;"17 1/2"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172733"><A NAME="_Ref465173567"><A NAME="_Toc465260975"> 
  (set &lt;символ&gt; &lt;выражение&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Присваивает &lt;символу&gt; (где &lt;символ&gt; - имя символа с кавычкой спереди) значение &lt;выражения&gt; и возвращает это значение. </P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(set 'a 5.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает 5.000000&#9;и устанавливает в символ А</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(set (quote b) 'a)</font><FONT FACE="Times New Roman">&#9;возвращает А&#9;&#9;и устанавливает в символ В.</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если SET используется с символьным именем без кавычки, она может присвоить новое значение косвенно другому символу.</P>
<P ALIGN="JUSTIFY">Например, возьмем вышеприведенные примеры:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(set b 640)</font><FONT FACE="Times New Roman">&#9;вернет  640</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">и присвоит значение 640 символу А (поскольку это значение символа В).</P>
<P ALIGN="JUSTIFY">Смотрите также ниже SETQ.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172734"></A><A NAME="_Ref465173568"></A><A NAME="_Toc465260976"></A><FONT FACE="Arial"> 
  (setq &lt;символ1&gt; &lt;выражение1&gt; [&lt;символ2&gt; &lt;выражение2&gt;]...)</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция устанавливает в &lt;символ1&gt; значение &lt;выражения1&gt;, в &lt;символ2&gt; значение &lt;выражения2&gt; и т.д. Это основная функция присвоения в AutoLISPе.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq a 5.0)</font><FONT FACE="Times New Roman">&#9;возвращает 5.000000</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">и присваивает значение 5.000000 символу А. Когда бы ни вычислялось A, оно будет вычисляться равным действительному числу 5.000000. </P>
<P ALIGN="JUSTIFY">Другие примеры:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq b 123 c 4.7)</font><FONT FACE="Times New Roman">&#9;возвращает 4.7</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq s "it")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает "it"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq x '(a b))</font><FONT FACE="Times New Roman">&#9;возвращает (A B)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функции SET и SETQ создают или модифицируют глобальные символы в тех случаях, когда функции не используются в функции DEFUN для присваивания значений аргументу функции или символу, объявленному как локальному для этой DEFUN.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq glo1 123)     ;</font><FONT FACE="Times New Roman">&#9;создание глобального символа</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(defun demo (arg1 arg2 / loc1 loc2)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq arg1 234)  ;</font><FONT FACE="Times New Roman">&#9;&#9;присвоение нового локального значения</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq log1 345)  ;</font><FONT FACE="Times New Roman">&#9;&#9;присвоение нового локального значения</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq glo1 456)  ;</font><FONT FACE="Times New Roman">&#9;&#9;присвоение нового глобального значения</font></P><DIR><DIR>
<FONT FACE="Times New Roman">

</font><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq glo2 567)  ;</font><FONT FACE="Times New Roman">&#9;&#9;создание нового глобального символа</font></P></DIR>
</DIR>

<FONT FACE="Courier New"><P ALIGN="JUSTIFY">    )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Глобальные символы доступны или изменяемы любой функцией или используемы в любом выражении. Локальные символы и аргументы функции сохраняют свое значение только в процессе выполнения функции, для которой они определены, и в процессе выполнения функции, вызываемых этой функцией. Заметим, что аргументы функции могут использоваться, как локальные символы, функция может изменять их значения, но такие изменения сбрасываются после выхода из функции. </P>
<P ALIGN="JUSTIFY">SET и SETQ допускают присвоение новых значений встроенным символам и  именам функций AutoLISP, сбрасывая первоначально присвоенные значения или  делая их недоступными. Некоторые пользователи тщетно пытаются сделать следующее:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq anagle (...))</font><FONT FACE="Times New Roman">&#9;&#9;Неверно!</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq length (...))</font><FONT FACE="Times New Roman">&#9;&#9;Неверно!</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq max (...))</font><FONT FACE="Times New Roman">&#9;&#9;Неверно!</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq t (...))</font><FONT FACE="Times New Roman">&#9;&#9;&#9;Неверно!</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq pi 3.0))</font><FONT FACE="Times New Roman">&#9;&#9;&#9;Неверно!</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Чтобы избежать всех видов таких странных ошибок, будьте внимательны,  когда придумываете имена своим символам. Никогда не используйте встроенный символ или имя функции для своего символа! (Для уничтожения списка  имен символов наберите "!АТОМLIST" на запрос "Command:" AutoCAD перед загрузкой (LOAD) какой-либо функции AutoLISP.)</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172735"><A NAME="_Ref465173572"><A NAME="_Toc465260977">(setvar 
  &lt;имя-переменной&gt; &lt;значение&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция присваивает системной переменной AutoCAD заданное &lt;значение&gt; и возвращает это значение. Имя переменной должно быть заключено в двойные кавычки.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setvar "FILLETRAD" 0.50)</font><FONT FACE="Times New Roman">&#9;возвращает 0.500000</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">устанавливает радиус сопряжения в AutoCAD равным 0.5 единиц.</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Некоторые команды AutoCADа выбирают системные переменные без всяких подсказок. Если Вы используете SETVAR для установления нового значения системной переменной в процессе выполнения некоторой команды, эта установка будет иметь силу только когда Вы начнете выполнять следующую команду AutoC</font>A<FONT FACE="Times New Roman">Dа. Список текущих системных переменных AutoCAD можно найти в приложении А руководства AutoCAD. Смотрите также функцию GETVAR.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172736"><A NAME="_Ref465173573"><A NAME="_Toc465260978">(sin 
  &lt;угол&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает синус &lt;угла&gt; как действительное число, где &lt;угол&gt; выражен в радианах.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(sin 1.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает  0.841471</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(sin 0.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает  0.000000</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172737"><A NAME="_Ref465173574"><A NAME="_Toc465260979">(sqrt 
  &lt;число&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает квадратный корень &lt;числа&gt; как действительное число.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(sqrt 4)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает 2.000000</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(sqrt 2.0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает 1.414214</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172738"><A NAME="_Ref465173575"><A NAME="_Toc465260980">(strcase 
  &lt;строка&gt; [&lt;признак&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">STRCASE берет строковую константу, указанную аргументом &lt;строка&gt; и возвращает ее копию, переведя все символы алфавита в верхний или нижний регистр в зависимости от аргумента &lt;признак&gt;. Если &lt;признак&gt; опущен или равен nil, то все символы алфавита в &lt;строке&gt; будут переведены в нижний регистр.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(strcase "Sample")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает  "SAMPLE"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(strcase "Sample" Т)</font><FONT FACE="Times New Roman">&#9;возвращает  "sample"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172739"><A NAME="_Ref465173576"><A NAME="_Toc465260981">(strcat 
  &lt;строка1&gt; &lt;строка2&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает строку, которая является результатом сцепления &lt;строки1&gt;, &lt;строки2&gt;  и т.д.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(strcat "a" "bout")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает "about"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(strcat "a" "b" "c")</font><FONT FACE="Times New Roman">&#9;возвращает "abc"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(strcat "a" "" "c")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает "ac"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172740"><A NAME="_Ref465173577"><A NAME="_Toc465260982">(strlen 
  &lt;строка&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает длину в символах строковой константы &lt;строка&gt; как целую величину.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(stalen "abcd")&#9;</font><FONT FACE="Times New Roman">возвращает 4</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(stalen "ab")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает 2</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(stalen "")</font><FONT FACE="Times New Roman">&#9;&#9;возвращает 0</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172741"><A NAME="_Ref465173578"><A NAME="_Toc465260983">(subst 
  &lt;новый элемент&gt; &lt;старый элемент&gt; &lt;список&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция просматривает &lt;список&gt; в поиске &lt;старых элементов&gt; и возвращает копию &lt;списка&gt; с заменой каждого встречного &lt;старого элемента&gt; на &lt;новый элемент&gt;. Если &lt;старый элемент&gt; не найден в &lt;списке&gt;, SUBST возвращает &lt;список&gt; неизменным. </P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq sample '(a b (c d) b))</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(subst 'qq 'b sample)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает (A QQ (C D) QQ)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(subst 'qq 'z sample)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает (A B (C D) B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(subst 'qq '(c d) sample)</font><FONT FACE="Times New Roman">&#9;возвращает (A B QQ B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(subst '(qq 'rr) '(c d) sample)</font><FONT FACE="Times New Roman">возвращает (A B (QQ RR) B)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(subst '(qq 'rr) 'z sample)&#9;</font><FONT FACE="Times New Roman">возвращает (A B (C D) B)</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В сочетании с функцией ASSOC, SUBST обеспечивает удобный способ замены величины, найденной по ключу в структурированном списке. </P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(stq who '((ferst john) (mid q) (last public)))</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq old</P>
<P ALIGN="JUSTIFY">     (assoc 'first who)</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">    )&#9;&#9;&#9;&#9;</font><FONT FACE="Times New Roman">возвращает (FIRST JOHN)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq new '(first j))</font><FONT FACE="Times New Roman">&#9;возвращает (FIRST J)</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(setq new old who)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает ((FIRST J) (MID Q) (LAST PUBLIC))</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172742"><A NAME="_Ref465173579"><A NAME="_Toc465260984">(substr 
  &lt;строка&gt; &lt;начало&gt; [&lt;длина&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает подстроку &lt;строка&gt;, начинающуюся с &lt;начал&gt;ьного символа и содержащую число символов, заданное в аргументе &lt;длина&gt;. Если &lt;длина&gt; не указана, то подстрока продолжается до конца &lt;строки&gt;. &lt;Начало&gt; (и длина, если присутствует) должны быть положительными целыми величинами. Первый символ &lt;строки&gt; - символ с номером 1.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(substr "abcde" 2)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает "bcde"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(substr "abcde" 2 1)</font><FONT FACE="Times New Roman">&#9;возвращает "b"</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(substr "abcde" 3 2)</font><FONT FACE="Times New Roman">&#9;возвращает "cd"</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172743"><A NAME="_Ref465173581"><A NAME="_Toc465260985"> 
  (terpri)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Эта функция печатает новую строку на экране. Она также возвращает новую строку. TERPRI не используется для ввода/вывода файлов. Для записи новой строки в файл используйте PRINT или PRI</font>NC.</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172744"><A NAME="_Ref465173585"><A NAME="_Toc465260986">(textscr)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция TEXTSCR переключает экран с графического в текстовой режим в одно-экранных системах (как функциональная клавиша "FLIP SCREEN" в AutoCAD). TEXTSCR всегда возвращает nil. Смотрите также функцию GRAPHSCR.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172745"></A><A NAME="_Ref465173586"></A><A NAME="_Toc465260987"></A><FONT FACE="Arial">(trace 
  &lt;функция&gt;..</font><FONT FACE="Arial">.)</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция - средство отладки. Она устанавливает знак трассировки для заданных &lt;функций&gt; и возвращает имя последней функции. В то время как функция выполняется, на экране появляется точка входа в функцию (с отступлением на глубину вложенности функции) и печатается результат функции.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(trase my-func)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;MY-FUNC</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">и устанавливает символ трассировки для функции MY-FUNC. Смотрите также функцию UNTRACE.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172746"><A NAME="_Ref465173587"><A NAME="_Toc465260988">(type 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает TYPE (тип) &lt;элемента&gt;, где TYPE - одно из следующих значений (как атом):</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">REAL&#9;&#9;числа с плавающей запятой</P>
</FONT><P ALIGN="JUSTIFY">FILE&#9;&#9;<FONT FACE="Times New Roman">описатель файлов</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">STR&#9;&#9;строковые константы</P>
<P ALIGN="JUSTIFY">INT&#9;&#9;целые величины</P>
<P ALIGN="JUSTIFY">SYM&#9;&#9;символы</P>
<P ALIGN="JUSTIFY">LIST&#9;&#9;списки (и функции пользователя)</P>
<P ALIGN="JUSTIFY">SUBR&#9;&#9;внутренние функции AutoLISP</P>
<P ALIGN="JUSTIFY">PITCKSET&#9;наборы AutoCAD</P>
<P ALIGN="JUSTIFY">ENAME&#9;имена примитивов AutoCAD</P>
<P ALIGN="JUSTIFY">PAGETB&#9;таблица диспетчера страниц</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 123 r 3.45 s "Hello!" x '(a b c))</P>
<P ALIGN="JUSTIFY">(setq f (open "name" "r"))</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type 'a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;SYM</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type a)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;INT</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type f)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;FILE</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type r)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;REAL</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type s)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;STR</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type x)&#9;&#9;</font><FONT FACE="Times New Roman">возвращает&#9;LIST</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(type +)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает&#9;SUBR</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Следующий пример иллюстрирует использование функции TYPE.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(defun isint (a)</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">   (if (= (type a) 'INT)    ;      является ли тип целым?</P>
<P ALIGN="JUSTIFY">            Т                   ;      если да - верни Т</P>
<P ALIGN="JUSTIFY">            nil                 ;      если нет - верни nil</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">       )</P>
<P ALIGN="JUSTIFY">    )</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
</FONT><B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172747"><A NAME="_Ref465173589"><A NAME="_Toc465260989"> 
  (untrace &lt;функция&gt;...)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Эта функция убирает символ трассирования для указанных функций и возвращает имя последней функции. Она выборочно исключает пошаговое трассирование</font>. </P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Hапример:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(untrace my-func)</font><FONT FACE="Times New Roman">&#9;возвращает   MY-FUNC</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">и убирает символ трассировки для функции MY-FUNC. Смотрите также TRACE.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172748"><A NAME="_Ref465173590"><A NAME="_Toc465260990"> 
  (ver)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает строковую константу, которая является номером текущей версии AutoLISP. Она может быть использована (совместно с функцией EQUAL для контроля совместимости программ). Форма строки:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">"AutoLISP Release X.X"</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">где Х.Х - номер текущей версии. Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">(ver)&#9;возможный возврат&#9;"AutoLISP Release 9.0"</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172749"><A NAME="_Ref465173591"><A NAME="_Toc465260991"> 
  (while &lt;тест-выражение&gt; &lt;выражение&gt;...)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция вычисляет &lt;тест-выражение&gt; и, если оно не является nil, вычисляет другие выражения, затем снова проверяет &lt;тест-выражение&gt;. Это продолжается до тех пор, пока &lt;тест-выражение&gt; не nil. Затем WHILE возвращает самое позднее значение последнего &lt;выражения&gt;.</P>
<P ALIGN="JUSTIFY">Например, дано:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(setq a 1)</P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">тогда:</P>
</FONT><FONT FACE="Courier New"><P ALIGN="JUSTIFY">(while (&lt;= a 10)</P>
<P ALIGN="JUSTIFY">    (some-func a)</P>
<P ALIGN="JUSTIFY">    (setq a (1+ a))</P>
<P ALIGN="JUSTIFY">    )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">будет вызвана функция пользователя SOME-FUNC десять раз, с А равным от 1 до 10. Будет затем возвращено 11, что является значением последнего выражения.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172750"></A><A NAME="_Ref465173592"></A><A NAME="_Toc465260992"></A><FONT FACE="Arial">(write-char 
  &lt;число&gt; [&lt;описатель файла&gt;])</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция записывает один символ на экран или в открытый файл, заданный &lt;описателем файла&gt;. &lt;число&gt;) - это код ASII символа, и является значением возвращаемым функцией.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(write-char 67)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;67 и записывает латинскую букву С на экране.</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Предположим, что F - описатель открытого файла:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(write-char 67 f)</font><FONT FACE="Times New Roman">&#9;возвращает&#9;67 и записывает латинскую букву С в этот файл.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172751"><A NAME="_Ref465173593"><A NAME="_Toc465260993">((write-line 
  &lt;строка&gt; [&lt;описатель файла&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция записывает строковую константу &lt;строка&gt; на экране или в открытый файл, заданный &lt;описателем файла&gt;. Она возвращает &lt;строку&gt;, взятую в кавычки, и опускает кавычки, когда записывается в файл. Например, предположим, что F это допустимый описатель открытого файла:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(write-line "Test" f)</font><FONT FACE="Times New Roman">&#9;записывает&#9;Test&#9;и возвращает&#9;"Test".</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172752"><A NAME="_Ref465173594"><A NAME="_Toc465260994">(zerop 
  &lt;элемент&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает T, если &lt;элемент&gt; действительное или целое число, равное нулю, иначе возвращает nil. Она не определена для других типов &lt;элементов&gt;.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(zerop 0)</font><FONT FACE="Times New Roman">&#9;&#9;возвращает Т</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(zerop 0.0)</font><FONT FACE="Times New Roman">&#9;возвращает Т</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(zerop 0.0001)&#9;</font><FONT FACE="Times New Roman">возвращает nil</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172753"><A NAME="_Ref465173601"><A NAME="_Toc465260995"> 
  (*error* &lt;строка&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Это, определяемая пользователем функция, трактующая ошибки. Если она не nil, она выполняется как функция всякий раз, когда присутствует проверка ошибок AutoLISP. Она выдает один аргумент - строку, состоящую из описания ошибки.</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(defun *error* (msg)</P>
<P ALIGN="JUSTIFY">   (princ "error:")</P>
<P ALIGN="JUSTIFY">   (princ msg)</P>
<P ALIGN="JUSTIFY">   (terpri)</P>
<P ALIGN="JUSTIFY">     )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция будет делать то же самое, что и стандартная функция трактовки ошибок AutoLISP - печать "error:" и описание. </P>
</FONT><P ALIGN="JUSTIFY"></P>
<B><FONT FACE="Times New Roman" SIZE=4 COLOR="#000000">
<h2><A NAME="#2">ПРИМИТИВЫ И МЕХАНИЗМ ДОСТУПА</A></h2>
<P><A HREF="#21">Специальные типы данных&#9;</A></P>
</font></B><FONT FACE="Times New Roman"></FONT> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#22">Манипуляция 
  функцией selection - set&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#23">Функции 
  имени примитива (entity name)&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></FONT><A HREF="#24">Функции 
  данных примитива (entity data)&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#25">Применение 
  в AutoCADе имен примитивов и наборов выбора&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#26">Доступ 
  к таблице символов&#9;</A></P>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#27">Доступ 
  к графическому экрану и устройствам ввода&#9;</A></P>

<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#28">Образцы 
  программ&#9;</A></P>

<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Всеобъемлющие функции AutoLISPа "set"  обеспечивают доступ к примитивам AutoCADа, к графическому экрану и к механизмам ввода. Вы можете выбирать примитивы , восстанавливать их величины  и модифицировать их. Наборы выбора (selection - sets ) можно поместить в переменные LISPа, это позволяет работать коллекции примитивов. Для прямого создания примитивов нет функций, однако можно использовать функцию COMMAND , чтобы подчиниться обычным командам AutoCAD для выполнения этого.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172754"><A NAME="_Ref465173602"><A NAME="_Ref465174193"><A NAME="_Toc465260998">Специальные 
  типы данных</A></A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Два специальных типа данных AutoLISPа являются инструментом , обеспечивающим доступ к примитивам AutoCAD: имя примитива ( entity name ) и набор выборa ( selection - set ). Этими типами данных манипулируют только функции , которые действуют на основании их , и их внутренняя структура не касается программиста LISP. Имя примитива имеет значение в указателе файла, обслуживающем редактор чертежей AutoCAD, в котором AutoLISP может найти базу данных примитивов или их векторы (если есть вывод на экран). Наборы выбора это просто коллекция имен примитивов.</P>
<P ALIGN="JUSTIFY">Имена примитивов и наборы выбора действительны только в течение  сеанса редактирования , в котором они применяются  AutoCADом. </P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172755"><A NAME="_Ref465174196"><A NAME="_Toc465260999">Манипуляция 
  функцией selection - set</A></A></A></P>
</font></i></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261000">( 
  ssget [&lt; режим &gt;] [&lt;точ1&gt; [&lt;точ2&gt;]])&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261001">( sslength &lt;ss&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261002">(ssname &lt;ss&gt; &lt;index&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261003">(ssadd [&lt;ename&gt; [&lt;ss&gt;]])&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261004">(ssdel &lt;ename&gt; &lt;ss&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261005">(ssmemb &lt;ename&gt; &lt;ss&gt;)&#9;</A></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Следующие функции выполняют различные действия на основании функции selection - sets (наборы выбора ).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172756"><A NAME="_Ref465174197"><A NAME="_Toc465261000">( 
  ssget [&lt; режим &gt;] [&lt;точ1&gt; [&lt;точ2&gt;]])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Вы можете применять функцию selection - set c функцией SSGET. Аргументом &lt; режим &gt; является строковая константа , которая означает тип выполняемого выбора примитива . Это могут быть буквы " W " , " C " , " L" , или " P " , названия режимов в AutoCADе " Window" (окно) , Crossing "(пересечение) , " Last " (последний), " Previous" (предыдущий). &lt; точ1 &gt; и &lt; точ2 &gt; это аргументы точки в списках , которые определяют точки , уместные для выбора. Обозначение точки без аргумента &lt; режим &gt; эквивалентно выбору примитива указанием единственной точки. Если все аргументы опущены , SSGET подскажет пользователю через механизм AutoCADа " Select objects: "(выберите объекты) , позволяя интерактивный выбор набора.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Примеры</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ssget)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;Спрашивает пользователя общий выбор примитива</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ssget "P")</font><FONT FACE="Times New Roman">&#9;&#9;Выбирает самый новый выбранный набор.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ssget "L")</font><FONT FACE="Times New Roman">&#9;&#9;Выбирает последний примитив, прибавленный к базе данных.</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ssget '(2 2))</font><FONT FACE="Times New Roman">&#9;&#9;Выбирает примитив, проходящий через точку 2 , 2 .</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ssget "W" '(0 0) '(5 5))</font><FONT FACE="Times New Roman"> Выбирает примитивы внутри окна с координатами точек 0, 0  5 ,5 .</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(ssget "C" '(0 0) '(1 1))</font><FONT FACE="Times New Roman"> Выбирает примитивы, пересекающие бокс с координатами точек 0 , 0   1 , 1 .</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Выбранные объекты высвечиваются, когда SSGET используется без аргументов. Нет информации о том, сколько выбранных примитивов сохраняется (как альтернативу смотри функцию ENTSEL , описанную ниже). Selection -sets временно поглощают щели файла AutoCAD , поэтому LISPу не разрешается иметь более 6-и  одновременно открытых файлов. Если этот предел достигнут , AutoCAD откажется создавать любые другие наборы выбора (selection -sets) и возвратит " nil " на все вызовы AutoCADа.</P>
<P ALIGN="JUSTIFY">Переменная набора выбора может быть передана AutoCADу в ответ на любую подсказку "Select objects:" в  выборе  "Last". Она выберет все объекты в наборе LISPа, как бы просматривая их в окошко (обратите внимание, примитивы, выбранные этим способом не нуждаются в выводе на экран).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172757"><A NAME="_Ref465174198"><A NAME="_Toc465261001">( 
  sslength &lt;ss&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает целое число , содержащее количество примитивов в наборе выбора &lt;ss&gt;. Наборы никогда не содержат дубликатов примитивов.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172758"><A NAME="_Ref465174199"><A NAME="_Toc465261002"> 
  (ssname &lt;ss&gt; &lt;index&gt;)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает имя примитива &lt;index&gt;-го элемента набора &lt;ss&gt;. Если &lt;index&gt; отрицательное или больше самого большего вычисляемого примитива в наборе выбора , возвращается  "nil". Первый элемент набора имеет индекс "0". Имена примитивов в  наборе , применяемых с функцией SSGET , всегда будут именами главных примитивов . Подпримитивы (Block attributes и Polyline vertices) не будут возвращаться ( но, смотри описанную ниже функцию ENTNEXT, которая делает доступными их).</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172759"><A NAME="_Ref465174200"><A NAME="_Toc465261003">(ssadd 
  [&lt;ename&gt; [&lt;ss&gt;]])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если вызывается без аргументов, функция SSADD создает новый набор выбора без членов. Если вызывается с единственным аргументом имени примитива, функция SSADD создает новый набор выбора, содержащий это единственное имя примитива. Если вызывается с именем примитива и с набором выбора, она добавляет имя примитива к набору. Функция SSADD всегда возвращает новый или модифицированный набор. Запомните, что при добавлении примитива к набору, новый примитив физически присоединяется к существующему набору, и набор, проходящий как &lt;ss&gt;, возвращается, как результат. Таким образом, если другим переменным присваивается категория - набор, они будут отражать также сложение. Если в наборе уже есть примитив с таким же названием, действие функции SSADD будет проигнорировано; сообщения об ошибке не будет.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172760"><A NAME="_Ref465174205"><A NAME="_Toc465261004">(ssdel 
  &lt;ename&gt; &lt;ss&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция SSDEL удаляет имя примитива &lt;ename&gt; из  набора &lt;ss&gt; и возвращает имя  набора &lt;ss&gt;. Запомните , что примитивы физически удаляются из набора , как оппозиция новому набору, возвращающемуся с удаленным элементом. Если в наборе нет примитива, возвращается "nil".</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172761"><A NAME="_Ref465174206"><A NAME="_Toc465261005"> 
  (ssmemb &lt;ename&gt; &lt;ss&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция проверяет , является ли имя примитива &lt;ename&gt; членом набора выбора &lt;ss&gt;. Если это так , функция SSMEMB возвращает имя примитива &lt;ename&gt;. Если нет, возвращает "nil".</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172762"><A NAME="_Ref465174207"><A NAME="_Toc465261006">Функции 
  имени примитива (entity name)</A></A></A></P>
</FONT>
</i></B>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261007">(entnext [&lt;ename&gt;])&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261008">(entlast)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261009">(entsel [&lt;prompt&gt;])&#9;</A></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Следующие функции выполняют различные действия с именем примитива, включая  ввод. Имена примитивов могут проходить в AutoCADе в ответ на любую подсказку " Select objects: " , для которой ответ "Last" действителен. В результате будет выбрано название примитива , как если бы он просматривался в окошко.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172763"><A NAME="_Ref465174208"><A NAME="_Toc465261007">(entnext 
  [&lt;ename&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Если вызывается без аргументов, эта функция возвращает имя примитива первого неудаленного примитива в базе данных. Если функция ENTNEXT вызывается с аргументом примитива &lt;ename&gt;, она возвращает имя первого неудаленного примитива, следующего за &lt;ename&gt; в базе данных. Если нет следующего примитива в базе данных, возвращается "nil". Функция ENTNEXT возвращает и главные примитивы и подпримитивы.</P>
<P ALIGN="JUSTIFY">Примитивы , выбранные функцией SSGET - главные примитивы, нет атрибутов блоков или вершин  полилиний. Вы можете добраться до внутренней структуры этих сложных примитивов посредством  простого приема, через  подпримитивы, функцией ENTNEXT. Если вы однажды примените имя подпримитива, вы можете действовать подобным  образом в любом другом случае. Если вы приобрели имя подпримитива через функцию ENTNEXT, вы можете найти родительский примитив, двигаясь вперед от функции ENTNEXT до функции SEQEND, чтобы обнаружить примитив, затем извлекая -2 группу из такого примитива, который  является главным именем примитива.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172764"><A NAME="_Ref465174209"><A NAME="_Toc465261008">(entlast)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция возвращает имя последнего неудаленного главного примитива в базе данных. Эта  функция часто применяется , чтобы дать имя новому примитиву , который только что был прибавлен через функцию COMMAND. Примитив не нужно выводить на экран, и также не нужно выбирать уровень.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172765"><A NAME="_Ref465174210"><A NAME="_Toc465261009"> 
  (entsel [&lt;prompt&gt;])</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Она иногда желательна, как действие на примитивы, чтобы одновременно выбрать примитив и обозначить точку, с помощью которой примитив был выбран. Примеры этого в AutoCADе можно найти в функции Object Snap и в командах BREAK , TRIM , EXTEND . Функция ENTSEL</font> <FONT FACE="Times New Roman">позволяет программам AutoLISPа выполнить это действие. Функция ENTSEL выбирает отдельный примитив, требуя, чтобы выбор был сделан точкой. Она возвращает список, в котором первый элемент - имя выбранного примитива, второй элемент - координаты точки, используемой для выбора примитива. Если строка содержит &lt;подсказку&gt;, эта строка может быть использована, чтобы спросить пользователя о примитиве. Иначе, по умолчанию появится подсказка "Select object:" . Следующий диалог иллюстрирует использование функции ENTSEL</FONT> <FONT FACE="Times New Roman">и возвращаемый список.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">       Command:       Line</P>
<P ALIGN="JUSTIFY">                      ----</P>
<P ALIGN="JUSTIFY">       From point:   1 , 1</P>
<P ALIGN="JUSTIFY">                     ------</P>
<P ALIGN="JUSTIFY">       To point:     6 , 6</P>
<P ALIGN="JUSTIFY">                     ------</P>
<P ALIGN="JUSTIFY">       To point:     RETURN</P>
<P ALIGN="JUSTIFY">                     ------</P>
<P ALIGN="JUSTIFY">       Command:   (setq e (entsel "Please choose an entity:"))</P>
<P ALIGN="JUSTIFY">                  ----------------------------------------------</P>
<P ALIGN="JUSTIFY">       Please choose an entity: 3 , 3</P>
<P ALIGN="JUSTIFY">                                -----</P>
<P ALIGN="JUSTIFY">   (&lt; Entity name: 60000014&gt; (3.000000 3.000000))</P>
<FONT COLOR="#ff0000"><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       Возвращаемая функцией ENTSEL форма в виде списка , удовлетворяет AutoCAD в ответ на любую его подсказку  выбрать объект. Это будет трактоваться  AutoCADом , как выбор определенного примитива , указанного точкой.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172766"><A NAME="_Ref465174211"><A NAME="_Toc465261010">Функции 
  данных примитива (entity data)</A></A></A></P>
</FONT>
</i></B>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261011">(entdel &lt;ename&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261012">(entget &lt;ename&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261013">(entmod &lt;elist&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261014">(entupd &lt;ename&gt;)&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261015">Ограничения&#9;</A></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Следующие функции позволяют вам восстановить и модифицировать данные определенных примитивов. Имена примитивов применяются для того, чтобы определить примитивы, с которыми надо работать.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172767"><A NAME="_Ref465174212"><A NAME="_Toc465261011"> 
  (entdel &lt;ename&gt;)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Удаляет примитив, обозначенный &lt;ename&gt;, в текущем чертеже, или восстанавливает примитив, если он был предварительно удален в этом сеансе редактирования. Удаляемые примитивы вычищаются из чертежа, покидая редактор чертежей, итак, функция ENTDEL может восстанавливать их только в течение сеанса редактирования, когда они были удалены. Функция ENTDEL работает только в главных примитивах, атрибуты и вершины полилиний не могут быть удалены, независимо от их родительских примитивов (вы можете использовать функцию COMMAND , чтобы работать функцией ATTEDIT, или</font> <FONT FACE="Times New Roman">команду PEDIT, чтобы выполнить это).</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172768"><A NAME="_Ref465174213"><A NAME="_Toc465261012">(entget 
  &lt;ename&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Примитив, который называется &lt;ename&gt; восстанавливается из базы данных и возвращается как список, содержащий эти определяемые данные. Результирующий список кодируется, как структурированный список LISP, элементы которого могут быть легко восстановлены функцией ASSOC. Объекты в результирующем списке кодируются в кодах DXF системы AutoCAD для каждой части входных данных. Для примера рассмотрим вычерчивание, и затем восстановление LINE следующей последовательностью команд:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT COLOR="#ff0000">        </font>Command: LINE</P>
<P ALIGN="JUSTIFY">                -----</P>
<P ALIGN="JUSTIFY">       From point: 1 , 2</P>
<P ALIGN="JUSTIFY">                  ------</P>
<P ALIGN="JUSTIFY">       To point: 6 , 6</P>
<P ALIGN="JUSTIFY">                 ------</P>
<P ALIGN="JUSTIFY">       To point: RETURN</P>
<P ALIGN="JUSTIFY">                --------</P>
<P ALIGN="JUSTIFY">       Command: (setq a (entget (entlast)))</P>
<P ALIGN="JUSTIFY">                ---------------------------</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">установит А, равное списку ( делает останов для прочтения ):</P>
</FONT><P ALIGN="JUSTIFY">   ( ( -1 .  &lt;Entity name: 60000014&gt;)</P>
<P ALIGN="JUSTIFY">     (0 .    "LINE")</P>
<P ALIGN="JUSTIFY">     (8 .    "0")</P>
<P ALIGN="JUSTIFY">     (10  1.000000 2.000000)</P>
<P ALIGN="JUSTIFY">     (11  6.000000 6.000000)</P>
<P ALIGN="JUSTIFY">        )</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Пункт -1 в начале списка содержит имя примитива, которым этот список представлен. Функция ENTMOD, описанная ниже, использует это, чтобы идентифицировать примитив  , который модифицирован.</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Отдельные точечные пары, представляют переменные, которые могут быть легко восстановлены с помощью функции ASSOC, функция CDR обычно выводит их значения. Коды для компонентов примитива те же самые, что использует DXF, и приводятся в приложении С Руководства AutoCAD. Так же, как в DXF, заголовок элемента  примитива ( цвет</font> <FONT FACE="Times New Roman">и тип линии, сложный примитив флага (функция ATFLAG), экструзия толщины и выключение набора Z) выводится , если переменная не по умолчанию. В функциях, не таких как DXF, не обязательно выводить точность поля примитива, равную ли их значениям по умолчанию или нет. Намерение сделать это является упрощенным вариантом программ, которые всегда могут принимать эти поля присутствующими для основных алгоритмов, по которым они работают.</font></P><FONT FACE="Times New Roman">
<B><I></i></B><P ALIGN="JUSTIFY"><U><I><B>Запомните</b></i></u>, что подсписки для точек - это не точечные пары, подобные остальным. Соглашением является то, что функция CDR подсписка - это групповая переменная. Так как точка- это список двух действительных чисел, это составляет всю совокупность трех элементов списка. Функция CDR группы является списком, изображающим точку, соглашением является также, то что функция CDR всегда возвращает переменную сохраненной.</P>
<P ALIGN="JUSTIFY">Когда описываемые функции обрабатывают эти списки, обязательно сделайте им аккуратные подсписки. Польза для функции ASSOC от этого гарантирована. Группа -1,содержащая имя примитивов, позволяет произвести некоторые действия, чтобы просто принять список примитива, и избежать необходимости сохранять имя примитива в параллельной структуре. Примитив SEQEND в конце Poliline или набор аттрибутов содержит -2группу, чьи CDR являются заголовком в этом примитиве. Это позволит найти заголовок в подпримитивах, двигаясь вперед к SEQEND, затем, используя функцию CDR -2 группы, как имя примитива, восстановить структурированный главный примитив. Следующий пример хорошо иллюстрирует комплексные примитивы, представленные как список.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">       Command: ELEV</P>
<P ALIGN="JUSTIFY">                -----</P>
<P ALIGN="JUSTIFY">       New current elevation &lt;0.0000&gt;: 3.5</P>
<P ALIGN="JUSTIFY">                                       ----</P>
<P ALIGN="JUSTIFY">       New current thickness &lt;0.0000&gt;: 0</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">                                     ---</P>
<P ALIGN="JUSTIFY">       Command: LINETYPE</P>
<P ALIGN="JUSTIFY">               ----------</P>
<P ALIGN="JUSTIFY">       ?/Create /Load/Set: SET</P>
<P ALIGN="JUSTIFY">                          ----</P>
<P ALIGN="JUSTIFY">       New entity linetype &lt;BYLAYER&gt;: DASHED</P>
<P ALIGN="JUSTIFY">                                      -------</P>
<P ALIGN="JUSTIFY">       Command:COLOR</P>
<P ALIGN="JUSTIFY">               ------</P>
<P ALIGN="JUSTIFY">       New entity color &lt;BYLAYER&gt;: BLUE</P>
<P ALIGN="JUSTIFY">                                   -----</P>
<P ALIGN="JUSTIFY">       Command: LAYER</P>
<P ALIGN="JUSTIFY">               -------</P>
<P ALIGN="JUSTIFY">       ?/Make/Set/New/On/Off/Color/Ltype/Freeze/Thaw: MAKE</P>
<P ALIGN="JUSTIFY">                                                      -----</P>
<P ALIGN="JUSTIFY">       New current layer &lt;0&gt;: ANNOTATION</P>
<P ALIGN="JUSTIFY">                             -------------</P>
<P ALIGN="JUSTIFY">       ?/Make/Set/New/On/Off/Color/Ltype/Freeze/Thaw: RETURN</P>
<P ALIGN="JUSTIFY">                                                     --------</P>
<P ALIGN="JUSTIFY">       Command: TEXT</P>
<P ALIGN="JUSTIFY">               ------</P>
<P ALIGN="JUSTIFY">       Start point or Align/Center/Fit/Middle/Right/Style: 2 ,2</P>
<P ALIGN="JUSTIFY">                                                          -------</P>
<P ALIGN="JUSTIFY">       Height &lt;0.2000&gt;: .3</P>
<P ALIGN="JUSTIFY">                       ----</P>
<P ALIGN="JUSTIFY">       Rotation angle &lt;0&gt;: 30</P>
<P ALIGN="JUSTIFY">                          -----</P>
<P ALIGN="JUSTIFY">       Text: So long , and thanks for all the fish!</P>
<P ALIGN="JUSTIFY">             ---------------------------------------</P>
<P ALIGN="JUSTIFY">       Command: (setq e (entget (entlast)))</P>
<P ALIGN="JUSTIFY">                -----------------------------</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В этом случае Е будет устанавливать в списке то, следует ниже.</P>
<P ALIGN="JUSTIFY">Рассмотрение приложения С Руководства к AutoCADу придаст смысл этому ясному списку.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">   (  (-1 . &lt;Entity name: 6000003C&gt;)</P>
<P ALIGN="JUSTIFY">      (0 .  "TEXT")</P>
<P ALIGN="JUSTIFY">      (8 .  "ANNOTATION")</P>
<P ALIGN="JUSTIFY">      (6 .  "DASHED"</P>
<P ALIGN="JUSTIFY">      (62.   5)</P>
<P ALIGN="JUSTIFY">      (38 .  3.500000)</P>
<P ALIGN="JUSTIFY">      (10 2.000000 2.000000)</P>
<P ALIGN="JUSTIFY">      (40 . 0.300000)</P>
<P ALIGN="JUSTIFY">      (1 .  "So long , and thanks for all the fish!")</P>
<P ALIGN="JUSTIFY">      (50 .  0.523598)</P>
<P ALIGN="JUSTIFY">      (41 .  1.000000)</P>
<P ALIGN="JUSTIFY">      (51 .  0.000000)</P>
<P ALIGN="JUSTIFY">      (7  .  "STANDARD")</P>
<P ALIGN="JUSTIFY">      (71 .  0)</P>
<P ALIGN="JUSTIFY">      (72 .  0)</P>
<P ALIGN="JUSTIFY">      (11  0.000000 0.000000)</P>
<P ALIGN="JUSTIFY">        )</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172769"><A NAME="_Ref465174215"><A NAME="_Toc465261013">(entmod 
  &lt;elist&gt;)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Список &lt;elist&gt; проходит функцию ENTMOD, в формате возвращающей его функции ENTGET, и обновляет информационную базу данных примитива, имя которого определено совокупностью -1 в &lt;elist&gt;. Однако, главный механизм, с помощью которого LISP обновляет базу данных, это восстановление примитивов функцией ENTGET, модификация списка, определяющего примитив ( запомните, что для этого очень полезна функция  SUBST AutoLISPа) и обновляющего примитив в базе данных с помощью функции ENTMOD.</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Функция ENTMOD имеет некоторые ограничения по изменениям, которые она делает. Во - первых, нельзя изменять типы примитивов . (Если вы хотите сделать это, примените только  функцию ENTDEL и сделайте новый примитив командой COMMAND ). AutoCAD должен знать все объекты, которые упоминаются в списке примитивов, до того</font> <FONT FACE="Times New Roman">как выполнена функция ENTMOD. Так, стиль текста, тип линии, форма  и имена блоков должны быть предварительно определены  в чертеже, до того, как функция ENTMOD может их использовать в списке примитивов. Исключением в этом случае является имя уровня, __ENT</FONT>M<FONT FACE="Times New Roman">OD освободит новый уровень по  умолчанию, используя команду "LAYER NEW", если в этом списке указывается предварительно не определенный уровень.</font></P><P ALIGN="JUSTIFY">
<FONT FACE="Times New Roman">Функция ENTMOD выполняет некоторую последовательность действий, как команда DXFIN, проверяя  список, содержит ли он, данные из файла DXF. Если обнаружена серьезная ошибка, такая серьезная,что база данных не обновляется, возвращается "nil". В противном случае, функция ENTMOD возвращает список в качестве аргумента. Функция ENTMOD не изменит внутренние поля, такие как</font> <FONT FACE="Times New Roman">имя примитива в совокупности -2 функции SEQEND, попытки изменить такие поля просто игнорируются.</font></P><P ALIGN="JUSTIFY">
<FONT FACE="Times New Roman">Когда обновляется главный примитив, функция ENTMOD будет модифицировать примитив и обновит изображение на экране ( включая под примитивы ) . Когда функция ENTMOD обычно обновляет подпримитив ( вершины полилиний, аттрибуты блоков ), подпримитив будет обновлен в базе данных, но изображение на экране не обновляется. После всех модификаций, которые сделаны с данными подпримитивами, можно использовать функцию ENTUPD</font>,<FONT FACE="Times New Roman"> описанную ниже, для обновления изображения на экране.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172770"><A NAME="_Ref465174216"><A NAME="_Toc465261014">(entupd 
  &lt;ename&gt;)</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Как описано выше, когда функция ENTMOD модифицирует вершины полилиний или аттрибуты блоков, полный комплект примитива не обновляется на экране. Например, если были модифицированы 100 вершин сложных полилиний, пересчет и перечерчивание Polyline, так же как и каждой вершины, которая была изменена, будет сделано неприемлемо медленно. Обычно, можно применить функцию ENTUPD, чтобы модифицированную  Polyline или блоки обновить на</font> <FONT FACE="Times New Roman">экране. Функция ENTUPD назовет именем примитива любую часть  Poliline или блока. Нет необходимости иметь заголовок примитива, функция ENTUPD найдет заголовок. Когда функция ENTUPD предназначена для полилиний и аттрибутов блоков, ее можно вызвать для любого примитива. Она всегда будет восстанавливать примитив на экране, включая все подпримитивы.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172771"><A NAME="_Ref465174217"><A NAME="_Toc465261015">Ограничения</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Имена примитивов ( entity names ) и наборы выбора ( selection- sets ) действительны только в течение сеанса редактирования,в котором они применяются в AutoCADе. Так, если вы попытаетесь произвести какие-нибудь последующие действия, пока активны команды PLINE или ATTEDIT, будет возвращено " nil" и запрос функции не будет выполнен.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">ENTMOD&#9;чтобы модифицировать существующий примитив</P>
<P ALIGN="JUSTIFY">ENTUPD&#9;чтобы восстановить модифицированный сложный примитив</P>
<P ALIGN="JUSTIFY">ENTDEL&#9;чтобы не удалять и восстановить уничтоженный примитив</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172772"><A NAME="_Ref465174218"><A NAME="_Toc465261016">Применение 
  в AutoCADе имен примитивов и наборов выбора</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Имена примитивов (entity name) и наборы выбора (selection-sets) необходимы для того, чтобы ввести из LISPа объекты выбора в ответ на подсказку. Таким образом, примитивы, названные LISPом, могут работать по командам AutoCADа. Подсказку "Select objects:" LISP может снабдить именем примитива, который определяет единственный примитив или набор выбора, чтобы выбрать все примитивы в наборе. Передача имен примитивов и набора выбора из LISPа возможна в выборе "Last"(обе части, как способность выбирать примитивы, не взирая на видимость, так и не специфицировать выбранные точки).</P>
<P ALIGN="JUSTIFY">Всякий раз, когда AutoCAD позволяет сделать выбор объекта точкой, списки в программе, возвращаемые функцией ENTSEL, допустят процедуру выбора. Они выбирают примитив из списка, определяя точку в списке, как выбранную точку. Это позволяет LISPу перейти к вводу выбранных точек такими командами, как BREAK, TRIM и EXTEND. Помните, что списки формы ENTSEL могут использоваться для других выборов тоже, так же точно, как точка, выбираемая позволяющей командой. Списки формы ENTSEL не могут использоваться с командами FILLET и CHAMFER, которые применяют два примитива и точки из механизма выбора.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172773"><A NAME="_Ref465174219"><A NAME="_Toc465261017">Доступ 
  к таблице символов</A></A></A></P>
</font></i></B>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261018">(tblnext &lt;table name&gt; [&lt;first&gt;]) 
  :&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261019">(tblsearch &lt;table name&gt; &lt;symbol&gt;&#9;</A></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Приведенные ниже функции TBLNEXT и TBLSEARCH снабжены таблицей символов, которая доступна только для чтения из AutoCADа уровня, типа линии, именованного вида, стиля текста и определения блока.:</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172774"><A NAME="_Ref465174224"><A NAME="_Toc465261018">(tblnext 
  &lt;table name&gt; [&lt;first&gt;]) :</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция используется для просмотра всех таблиц символов. Первый аргумент - это идентификатор символа интересующей вас таблицы. Действительны имена "LAYER" , "LTYPE" , "VIEW", "STYLE" и "BLOCK": Именам не нужен верхний регистр. Когда присутствует второй аргумент,   и не "nil", таблица символов переводится на начало и первый элемент в   ней восстанавливается, в противном случае , восстанавливается следующий элемент в таблице. Когда совсем нет элементов в таблице, возвращается "nil". Удаленные элементы таблицы не возвращаются.</P>
<P ALIGN="JUSTIFY">Когда элемент обнаружен, он возвращается, как список точечных пар DXF кодов и значений , подобно тому ,который возвращает функция ENTGET.</P>
<P ALIGN="JUSTIFY">Пример:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(tblnext  "layer" T)</font><FONT FACE="Times New Roman">&#9;восстанавливает первый уровень</font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">может вернуть :</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">((0 .  "LAYER")</font><FONT FACE="Times New Roman">&#9;символьный тип</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(2 .  "0")</font><FONT FACE="Times New Roman">&#9;&#9; имя символа</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(70 .  0)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;флаги</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(62 .  7)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;цвет, негатив выключен</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(6 .  "CONTINUOUS")</font><FONT FACE="Times New Roman">&#9;тип линии</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">     )</P>
</FONT><B><I><U></u></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"><U><I><B>Обратите внимание</b></i></u></font><FONT FACE="Times New Roman"> , что совокупности "-1" нет. AutoCAD запоминает: последний элемент , возвращаемый из таблицы, и просто возвращает один из следующих элементов ,при каждом вызове TABNEXTом этой таблицы. Когда вы начинаете просмотр таблицы , вы должны быть уверены , что второй аргумент не "nil", чтобы перемотать таблицу и вернуть первый элемент . Элементы, восстановленные из таблицы " BLOCK" , включают в себя  : совокупность "-2" c именем  первого примитива в определении  блока (или любого).</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Итак, назовем блок "BOX": </P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(tblnext  "block")</font><FONT FACE="Times New Roman">&#9;восстанавливает определение блока </font></P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">может вернуть:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">((0 . "BLOCK")</font><FONT FACE="Times New Roman">&#9;&#9;тип символа</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(2 . "BOX")</font><FONT FACE="Times New Roman">&#9;&#9;имя символа</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(70 . 0)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;флажки</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(10  9.000000 2.000000 0.000000)</font><FONT FACE="Times New Roman">&#9;Х,У,Z</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(-2 . &lt;Entity name: 40000126))</font><FONT FACE="Times New Roman">&#9;первый примитив</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">      )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Имя примитива в совокупности "-2" принимается функциями ENTGET и  ENTNEXT ,но ни какими другими функциями. Это значит, что вы не можете  модифицировать такой примитив функцией ENTMOD или использовать функции: SSADD или ENTSEL , чтобы поместить его в selectin-set. Применяя совокупность "-2"имени примитива в функции EN</font>T<FONT FACE="Times New Roman">NEXT, вы можете сканировать примитивы, сжимая определения блока; функция ENTNEXT возвращает "nil" после последнего примитива в определение блока.</font></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172775"><A NAME="_Ref465174225"><A NAME="_Toc465261019"> 
  (tblsearch &lt;table name&gt; &lt;symbol&gt;</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция просматривает таблицу символов, идентифицируемую  &lt;table name&gt; (то же самое, что функция TBLNEXT), отыскивая имя символа присвоенного &lt;symbol&gt;. Оба имени автоматически приводятся к верхнему регистру. Когда обнаружено имя элемента, подобное тому, которое дал &lt;symbol&gt;, эта запись возвращается в формате, описанном функцией TBLNEXT. Если такой элемент  не обнаружен, возвращается "nil"</P>
<P ALIGN="JUSTIFY">Например:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(tblsearch "style" "standard")</font><FONT FACE="Times New Roman">&#9;устанавливает стиль текста</font></P>
<P ALIGN="JUSTIFY"> </P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">может вернуть:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">((0 . "STYLE")</font><FONT FACE="Times New Roman">&#9;&#9;тип символа</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(2 . "STANDARD")</font><FONT FACE="Times New Roman">&#9;имя символа</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(70 .  0)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;флажки</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(40 .  0.000000)</font><FONT FACE="Times New Roman">&#9;фиксирование высоты</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(41 .  1.000000)</font><FONT FACE="Times New Roman">&#9;фактор ширины</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(50 .  0.000000)</font><FONT FACE="Times New Roman">&#9;угол</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(71 .  0)</font><FONT FACE="Times New Roman">&#9;&#9;&#9;генерирование флажков</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(3 .  "txt")</font><FONT FACE="Times New Roman">&#9;&#9; самый первый font file</font></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">(4 . "")</font><FONT FACE="Times New Roman">&#9;&#9;&#9;большой font file</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">    )</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Порядок вводов восстановлен из TBLNEXT без воздействия функции  TBLSEARCH.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172776"></A><A NAME="_Ref465174265"></A><A NAME="_Toc465261020"></A><FONT FACE="Arial">Доступ 
  к графическому экрану и устройствам ввода</font></P>
</i></B> 
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261021"> (grclear)&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261022">(grdraw &lt;from&gt; &lt;to&gt; &lt;color&gt; 
  [&lt;highlight&gt;])&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261023">( grtext [&lt;box&gt; &lt;text&gt; 
  [&lt;highlight&gt;]])&#9;</A></P>
<P ALIGN="JUSTIFY"><A HREF="#_Toc465261024">(grread [&lt;trac&gt;])&#9;</A></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функции AutoLISPа, описанные в этом разделе, обеспечивают прямой доступ к графическому экрану AutoCADа, и устраивают вход из LISPа, и позволяют средствами LISP-команд взаимодействовать с пользователем, как если бы выполнение было без AutoCADа. Эти команды могут устроить беспорядок на экране. Однако, любое повреждение, которое они наносят, может быть отменено последовательностью:</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY">(grtext)</P>
<P ALIGN="JUSTIFY">(redraw)</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">однако, нет нужды касаться этого. Эти функции только для опытных пользователей. Большинству применений LISPа не нужны  эти функции. Пользователей предупреждаем, что  действия этих функций могут быть изменены от выпуска к выпуску системы AutoCAD и, следовательно, Autodesk, поэтому нет гарантии указанной выше совместимости применений этих функций. Применение функций GRTEXT и GRREAD также может быть неподходяще, для работы на любой жесткой конфигурации, если пользователь не очень внимателен, чтобы аккуратно следовать правилам их использования, приведенным ниже.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172777"><A NAME="_Ref465174269"><A NAME="_Toc465261021">(grclear)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта функция очищает графический экран AutoCADа. (В системах с одним экраном она переключит графический экран с текстового режима на первый). Подсказка, статус и меню остаются неизменными. Оригинал может быть перевыведен на графический экран функцией REDRAW.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172778"><A NAME="_Ref465174270"><A NAME="_Toc465261022">(grdraw 
  &lt;from&gt; &lt;to&gt; &lt;color&gt; [&lt;highlight&gt;])</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция GRDRAW вычерчивает вектор между двумя точками . &lt;from&gt; и &lt;to&gt; являются точками (списки из двух действительных чисел), которые определяют конечные точки  вектора. Конечные точки определяются, как плавающие точки для вычерчивания координат и будет clipped, как требование, чтобы вывести на экран.  Вектор будет нарисован с цветным выводом, если аргумент &lt;color&gt; целое число, определяемое в группе -1 в "XOR ink", которая заканчивает любое его вычерчивание и уничтожается, когда перечерчено. Если аргумент &lt;highlight&gt; целое число и не "0", будет нарисован вектор так, как механизм дисплея высветит выбранные объекты ( обычно поточечно ). Если &lt;highlight&gt; пропущен или имеет значение 0, будет использован нормальный режим вывода на экран.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172779"><A NAME="_Ref465174271"><A NAME="_Toc465261023">( 
  grtext [&lt;box&gt; &lt;text&gt; [&lt;highlight&gt;]])</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Функция GRTEXT позволяет AutoLISPу выводить текст частями на графический экран в AutoCADе. Если вызывается с аргументом &lt;box&gt; от 0 и до самого высокого численного значения бокса в меню экрана минус 1, функция выведет на экран дисплея строковый  аргумент &lt;text&gt;, в указанный в меню бокс .  Текст&lt;text&gt; будет  сокращен, если он слишком длинный, и непригоден для бокса, и пустота заполнится пробелами, если текст короче. Если присутствует факультативный аргумент (целое число) &lt;highlight&gt; и он не 0, в предназначенном боксе будет высвечиваться текст. Если &lt;highlight&gt; присутствует и  0, текст в предназначенном боксе не будет высвечиваться ( запомните, что при высвечивании</font> <FONT FACE="Times New Roman">другого текста, бокс автоматически отменяет предыдущий текст, который был высвечен). Когда вы пишете в боксе, текст сначала должен быть написан без аргумента &lt;highlight&gt;, затем высвечен. Такая же текстовая строка, какая в оригинале вводится в бокс,  должна высвечиваться и не высвечиваться. Результатом несоблюдения этих правил будут  LISP программы, которые ведут себя по-разному на разных дисплеях. </font></P><FONT FACE="Times New Roman">
<B><I></i></B><P ALIGN="JUSTIFY"><U><I><B>Запомните,</b></i></u> что эта функция просто выводит на экран дисплея текст, находящийся в площади экрана ; она не изменяет элементы экранного меню.</P>
<P ALIGN="JUSTIFY">Если функция GRTEXT вызывается боксом  номер -1, текст будет выведен на экран в режиме статуса линии . Длина линии зависит от дисплея ( большинство их допускает, по крайней мере, 40 разновидностей, за исключением замечательного Color Graphics Adaptor фирмы IBM ). Текст будет сокращен, чтобы пригнать его к имеющемуся в распоряжении пространству .</P>
<P ALIGN="JUSTIFY">Если используется бокс с номером -2, текст будет написан в координатах статуса линии. Запомните, что если слежение координат включено, величины, записанные в это поле, перепишутся, как только указатель пошлет другой набор координат. Каждый из номеров, -1 или -2, игнорирует аргумент &lt;highlight&gt;, если он присутствует . Наконец, функция DRTEXT может быть вызвана без аргументов, чтобы восстановить всю площадь текста на экране, с его стандартными переменными.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172780"><A NAME="_Ref465174272"><A NAME="_Toc465261024">(grread 
  [&lt;trac&gt;])</A></A></A></P>
</font></i></B><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">Функция GRREAD позволяет вам непосредственно следить за механизмом входа AutoCADа, выслеживая указанные механизмы, когда они изменяются. Этой функции нужны только специфические команды, большинство входов в AutoLISP пройдут через различные функции GETxxx, такие как GETSTRING, GETREAL и подобные. Аргумент &lt;track&gt;, если он имеется и не "nil", дает возможность вернуть координаты из указанных механизмов, когда они</font> <FONT FACE="Times New Roman">двигаются, не требуя выбора нажатием клавиш. Этот механизм AutoCAD обычно использует для протягивания.</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">Функция GRREAD возвращает список, в котором первый элемент это код, определяющий тип входа. Второй элемент списка - любое целое число или список точек, зависящих от типа входа .Коды для первого элемента в списке следующие:</P>
<OL START=2>

<P ALIGN="JUSTIFY"><LI>характеризует клавиатуру - в кодах ASCII, также и для второго элемента</LI><p></P>
<P ALIGN="JUSTIFY"><LI>выбираемая точка - координаты, как список выбираемый элемент меню экрана - номер бокса, также и для второго элемента</LI><p></P>
<P ALIGN="JUSTIFY"><LI>режим протягивания координат, также и для второго элемента. Возвращается только, если второй аргумент определен и он не"nil"</LI><p></P>
<P ALIGN="JUSTIFY"><LI>BUTTONS выбираемый пункт меню - номер клавиши это второй элемент</LI><p></P>
<P ALIGN="JUSTIFY"><LI>TABLET1 оцифровываемый пункт меню - номер бокса это второй элемент</LI><p></P>
<P ALIGN="JUSTIFY"><LI>TABLET2 оцифровываемый пункт меню - номер бокса это второй элемент</LI><p></P>
<P ALIGN="JUSTIFY"><LI>TABLET3 оцифровываемый пункт меню - номер бокса это второй элемент</LI><p></P>
<P ALIGN="JUSTIFY"><LI>TABLET4 оцифровываемый пункт меню - номер бокса это второй элемент</LI><p></P>
<P ALIGN="JUSTIFY"><LI>AUXI оцифровываемый пункт меню - номер бокса это второй элемент</LI><p></P>
<P ALIGN="JUSTIFY"><LI>координаты, связанные с указателем клавиш, возвращаемые, как второй элемент. Всегда следует тип 6 , чтобы возвратить список</LI><p></P>
<P ALIGN="JUSTIFY"><LI>выбор высвеченного пункта меню экрана при помощи ввода с клавиатуры</LI><p></P></OL>

<P ALIGN="JUSTIFY">Ввод CTRL C в то время как идет GRREAD , вызовет прерывание (abort) LISP программы с клавиатуры. Любой другой вход пройдет прямо к GRREAD ,давая этим возможность закончить контроль над механизмом входа.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172781"><A NAME="_Ref465174273"><A NAME="_Toc465261025">Образцы 
  программ</A></A></A></P>
</font></i></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261026">Удаление 
  уровня&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261027">Установление 
  текущего уровня&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261028">Изменение 
  уровня примитива&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261029">Текстовый 
  редактор&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261030"> 
  Обновление данных&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261031">Список 
  типов линий&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261032">Воображаемое 
  окошко (ZOOM Window)&#9;</A></P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman"></font><A HREF="#_Toc465261033">Idle 
  ( работать вхолостую)&#9;</A></P>

<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Следующие LISP программы иллюстрируют возможности , описанные в этой главе.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172782"></A><A NAME="_Ref465174274"></A><A NAME="_Toc465261026"></A><FONT FACE="Arial">Удаление 
  уровня</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта программа выполняет команду DELLAYER , чтобы удалить все примитивы определенного уровня.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;    Удаление всех примитивов на определенном уровне</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">   (defun C : DELLAYER (/ e l)</P>
<P ALIGN="JUSTIFY">      (setq l (strcase (getstring "\nLayer to  delete?")))</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;    Запуск черчения сканированием первого примитива</P>
</FONT><P ALIGN="JUSTIFY">     (setq e (entnext))</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;    Проверка уровней этих примитивов (8 групп)</P>
</FONT><P ALIGN="JUSTIFY">     (while e       </P>
<P ALIGN="JUSTIFY">        (if (= l (cdr (assoc 8 (entget e))))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;    Корректирование уровня... удаление этого уровня</P>
</FONT><P ALIGN="JUSTIFY">      (entdel e)</P>
<P ALIGN="JUSTIFY">       )</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;    Взять следующий примитив</P>
</FONT><P ALIGN="JUSTIFY">       (setq e (entnext e))</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;    Останов до тех пор пока не будет больше примитивов</P>
</FONT><P ALIGN="JUSTIFY">)</P>
<P ALIGN="JUSTIFY">    )</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Функция DELLAYER проверяет  8 групп ( имя уровня ) каждого примитива чертежа, просматривая примитивы на специфицируемом уровне. Тестированием других групп вы можете выполнить команды, чтобы проверить все примитивы особых типов ( окружности, может быть) или все примитивы особых вычислений и прочее</P>
</FONT><P ALIGN="JUSTIFY"> </P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172783"><A NAME="_Ref465174279"><A NAME="_Toc465261027"> 
  Установление текущего уровня</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта программа выполняет команду SETLAYER , давая возможность  изменить текущий уровень просто указывая на существующий объект  этим уровнем. </P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Установить текущий уровнь этого существующего объекта          :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">   (defun C:SETLAYER ( / e n)                                       :</P>
<P ALIGN="JUSTIFY">      (setq e (car (entsel "Pick an object on the desired layer: ")))</P>
<P ALIGN="JUSTIFY">      (if e ( progn                                                 :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">        ; Взять входные данные групп                                    :</P>
</FONT><P ALIGN="JUSTIFY">         (setq e (entget e)                                         :</P>
<P ALIGN="JUSTIFY">             )                                                          :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">        ; Группа 8 - это имя уровня                                     :</P>
</FONT><P ALIGN="JUSTIFY">         (setq n (cdr (assoc 8 e)))                                 :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">        ; Результат выполнения команды "LAYER SET"                      :</P>
</FONT><P ALIGN="JUSTIFY">         (command "LAYER" "SET" n "")                               :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">           ))                                                           :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Вы можете использовать подобный подход , чтобы установить текущий цвет, тип линии, возвышение или толщину этих специфицируемых объектов </P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172784"><A NAME="_Ref465174280"><A NAME="_Toc465261028">Изменение 
  уровня примитива</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Это вариации команды SETLAYER , приведенной выше. Лучше, чем установление текущего уровня , эта команда изменяет выбранные объекты,  для того чтобы иметь тот же самый уровень , как и у другого выбранного объекта. </P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">   (defun C:CHGLAYER (/ ss e n)                                     :</P>
<P ALIGN="JUSTIFY">      (princ "Select objects to be change ...\n")                   :</P>
<P ALIGN="JUSTIFY"> </P>
<P ALIGN="JUSTIFY">                                                                            :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Основной набор выбора (selection-set)                          :</P>
</FONT><P ALIGN="JUSTIFY">      (setq ss(ssget))                                              :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ;Если любые выбранные объекты....                                :</P>
</FONT><P ALIGN="JUSTIFY">      (if ss (progn                                                 :</P>
<P ALIGN="JUSTIFY">         (setq e (car (entsel "Pick an object on the desired        :</P>
<P ALIGN="JUSTIFY">    layer: ")))                                                         :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Если объект был выбран...                                      :</P>
</FONT><P ALIGN="JUSTIFY">       (if e (progn                                                 :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Перейди на эту группу данных                                   :</P>
</FONT><P ALIGN="JUSTIFY">          (setq e (entget e))                                       :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Группа 8 - это имя уровня                                      :</P>
</FONT><P ALIGN="JUSTIFY">          (setq n (cdr (assoc 8 e)))                                :</P>
<P ALIGN="JUSTIFY">          (command "CHANGE" SS "" "PROP" "LAYER" n "")                :</P>
<P ALIGN="JUSTIFY">           ))                                                           :</P>
<P ALIGN="JUSTIFY">        ))                                                              :</P>
<P ALIGN="JUSTIFY">      )                                                                 :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">В этом примере наборы выбора ( selection - set)  объектов , которые можно изменить , устанавливаются символом SS. Можно применять однажды установленное имя уровня ( из 8 группы выбранного объекта), выбор   набора ( selection - set ) SS проходит к команде "CHANGE Properties"( изменение собственности) , чтобы вызвать эффект желаемого изменения.  </P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172785"><A NAME="_Ref465174281"><A NAME="_Toc465261029">Текстовый 
  редактор</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Программа, приведенная ниже , выполняет команду CHGTEXT для основного редактирования  текстов. Она допускает, что вы обозначаете "new string" (новая строка), чтобы ею заменить  в каждом случае старую строку ("old string"), которая обнаружена в выбранном тексте. Вы можете легко расширять это , чтобы любой текст по вашему желанию редактировался .</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      ; Изменение подстроки в выбранном текстовом примитиве</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">  (defun C:CHGTEXT (/ p l n e os as ns s nsl osl sl si chf chm)</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">     (setq p (ssget))        ; Выберите объекты</P>
<P ALIGN="JUSTIFY">     (if p (progn            ; Если любые объекты выбраны...</P>
</FONT><P ALIGN="JUSTIFY">        (setq osl (strlen (setq os (getstring "\nOld string: "t))))</P>
<P ALIGN="JUSTIFY">        (setq nsl (strlen (setq ns (getstring "\nNew string: "t))))</P>
<P ALIGN="JUSTIFY">        (setq l 0 chm 0 n (sslength p))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">        (while (&lt; l n)       ; Для каждого выбранного объекта...</P>
<P ALIGN="JUSTIFY">        (if (= "TEXT"        ; Смотри тип примитива ТЕКСТ (группа 0)</P>
</FONT><P ALIGN="JUSTIFY">               (cdr (assoc 0 (setq e (entget (ssname p l))))))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">           (progn            ; Обнаружен один... смотри старую строку</P>
</FONT><P ALIGN="JUSTIFY">              (setq chf nil si 1)</P>
<P ALIGN="JUSTIFY">              (setq s (cdr (setq as (assoc 1 e))))</P>
<P ALIGN="JUSTIFY">              (while (= osl (setq sl (strlen</P>
<P ALIGN="JUSTIFY">                            (setq st (substr s si osl)))))       </P>
<P ALIGN="JUSTIFY">                 (if (= st os) (progn</P>
<P ALIGN="JUSTIFY">                    (setq s (strcat (substr s 1 (1 si)) ns</P>
<P ALIGN="JUSTIFY">                                    (substr s (+ si ost))))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                    (setq chf t)  ; Обнаружена старая строка</P>
</FONT><P ALIGN="JUSTIFY">                     ))</P>
<P ALIGN="JUSTIFY">                 (setq si (1+ si))</P>
<P ALIGN="JUSTIFY">                 )</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">             (if chf (progn       ; Заменитель новой строки на старую</P>
</FONT><P ALIGN="JUSTIFY">                (setq e (subst (cons 1 s) as e))</P>
<P ALIGN="JUSTIFY">                (entmod e)        ;<FONT FACE="Times New Roman"> Текстовый примитив</font></P>
<P ALIGN="JUSTIFY">                (setq chm (1+ chm))</P>
<P ALIGN="JUSTIFY">                ))</P>
<P ALIGN="JUSTIFY">            )</P>
<P ALIGN="JUSTIFY">         )</P>
<P ALIGN="JUSTIFY">     (setq l (1+ l))</P>
<P ALIGN="JUSTIFY">      )</P>
<P ALIGN="JUSTIFY">   ))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (princ "Changed")                  ; Печать полностью измененных линий</P>
</FONT><P ALIGN="JUSTIFY">   (princ chm)</P>
<P ALIGN="JUSTIFY">   (princ " text lines.")</P>
<P ALIGN="JUSTIFY">   (terpri)</P>
<P ALIGN="JUSTIFY"> )</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Здесь, набор выбора Р (selесtion -set P) исследуется для примитивов текста , содержащих в себе специфицируемую старую строку( "old string"). Для каждого подобранного примитива текста, функции STRCAT и SUBSTR обычно формируют новую текстовую строку, которая во всех случаях заменяет старую строку (old string) на новую строку ( new string). Используя SUBST, вы построите новую строку, заменяющую группу 1 в текстовом примитиве, и затем обычно ENTMOD откорректирует примитив в базе данных чертежа и на экране.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172786"><A NAME="_Ref465174282"><A NAME="_Toc465261030">Обновление 
  данных</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Считайте, по соглашению ,что вы вставляете блок, называемый "TITLE", в каждый чертеж и , что этот блок имеет аттрибуты , называемые "REVDATE", которые означают данные последней ревизии. Следующая программа выполняет команду REVISE, которая обнаруживает этот блок и корректирует его аттрибуты. Сначала определяется пара функциональных утилит.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Ввод текущих данных в формате MM/DD/YY</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">   (defun mmddyy (/ x)</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq x (getvar "CDATE"))     ; Текущие данные</P>
</FONT><P ALIGN="JUSTIFY">      (set<FONT FACE="Times New Roman">q x (rtos x 2 0))         ; Обращение к строке</font></P>
<P ALIGN="JUSTIFY">      (setq date (strcat (substr x 5 2) "/"   ;MM</P>
<P ALIGN="JUSTIFY">                         (substr x 7 2) "/"   ;DD</P>
<P ALIGN="JUSTIFY">                         (substr x 3 2)))     ;YY</P>
<P ALIGN="JUSTIFY">       )</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Возврат содержания примитива поля "num"</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">   (defun fld (num)</P>
<P ALIGN="JUSTIFY">       (cdr (assoc num d))</P>
<P ALIGN="JUSTIFY">       )                                    </P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Поиск аттрибутов REVDATE в блоке TITLE и обновление</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">   (defun C:REVISE (/ e d date done)</P>
<P ALIGN="JUSTIFY">      (setq done nil)</P>
<P ALIGN="JUSTIFY">      (setq e (entnext)                   <FONT FACE="Times New Roman">; Первый объект в чертеже</font></P>
<P ALIGN="JUSTIFY">      (while e</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">         (setq d (entget e)               ; Получение групп данных</P>
<P ALIGN="JUSTIFY">                                              ;    примитива</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">         (if (and (= (fld 0) "INSERT")    ; Имеется ли INSERT ?</P>
</FONT><P ALIGN="JUSTIFY">                  (= (<FONT FACE="Times New Roman">fld 2) "TITLE")     ;  ...    имя TITLE?</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">                  (= (fld 66) 1))         ;  ...    АТТРИбУТЫ?</P>
</FONT><P ALIGN="JUSTIFY">            (progn</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">               (setq e (entnext e))       ; Получение подпримитива</P>
<P ALIGN="JUSTIFY">                                             (аттрибута)</P>
</FONT><P ALIGN="JUSTIFY">               (while e</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                  (setq d (entget e))     ; Получение подпримитивов</P>
<P ALIGN="JUSTIFY">                                              ;   групп данных</P>
<P ALIGN="JUSTIFY">                  (cond ((and (= (fld 0) "ATTRIB")   ; Искать</P>
</FONT><P ALIGN="JUSTIFY">                              (= (fld 2) "REVDAT<FONT FACE="Times New Roman">E")) ; Аттрибуты</font></P>
<P ALIGN="JUSTIFY">                                                         ;  REVDATE</P>
<P ALIGN="JUSTIFY">                           (mmddyy)</P>
<P ALIGN="JUSTIFY">                           (setq d (subst (cons 1 date) (assoc 1 d))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                               ; Новые данные</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">                   <FONT FACE="Times New Roman">        (entmod d)    ; Изменение аттрибутов</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">                                             ;  переменных</P>
<P ALIGN="JUSTIFY">                           (entupd e)    ; Регенерация блока</P>
<P ALIGN="JUSTIFY">                           (setq e nil done T))  ; Были выполнены</P>
</FONT><P ALIGN="JUSTIFY">                        ((= (fld 0) "ENDSEQ")</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                            (setq e nil)) ; Нет аттрибутов REVDATE;</P>
<P ALIGN="JUSTIFY">                                              ;  останов сканирования</P>
<P ALIGN="JUSTIFY">                        (T (setq e (entnext e))) ; Ввод следующего</P>
</FONT><P ALIGN="JUSTIFY">                              <FONT FACE="Times New Roman">                       ;   подпримитива</font></P>
<P ALIGN="JUSTIFY">                     )</P>
<P ALIGN="JUSTIFY">                  )</P>
<P ALIGN="JUSTIFY">              )</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          (setq e (entnext e))           ;Нет блока TITLE, вход</P>
<P ALIGN="JUSTIFY">                                             ;  следующего примитива</P>
</FONT><P ALIGN="JUSTIFY">          )</P>
<P ALIGN="JUSTIFY">       )</P>
<P ALIGN="JUSTIFY">   (if done "Revision date updated" "No REVDATE attribute found")</P>
<P ALIGN="JUSTIFY">    )</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Команда REVISE проверяет группу 0 ( тип примитива) каждого примитива в чертеже , просматривая упоминаемый блок ( функция INSERT), который назван " TITLE". Затем она сканирует подпримитивы этого блока (его аттрибуты), просматривая аттрибуты "REVDATE". Обнаруженная переменная аттрибутов изменится и блок введется.</P>
</FONT><P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172787"><A NAME="_Ref465174283"><A NAME="_Toc465261031"> 
  Список типов линий</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Этот пример использует функции доступа к таблице символов, чтобы внести в список имена и определения всех текуще-загруженных типов линий. </P>
</FONT><P ALIGN="JUSTIFY">                                                                            :                                                                         :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Пустая-полная  данная строка ,которая  определяет количество   знаков.                                                        :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">   (defun strfill (s len)                                           :</P>
<P ALIGN="JUSTIFY">      (substr (strcat s "                     ") 1 len)             :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Возврат переменной , связанной с отдельной группой примитива   :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">   (defun fld (num lst)                                             :</P>
<P ALIGN="JUSTIFY">      (cdr (assoc num lst))                                         :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">       ; Список загруженных типов линий       </font>                          :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">   (defun C:LTYPES (/ a cl d f lt s x)                              :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (textscr)                            ; Вывод текста на экран  :</P>
</FONT><P ALIGN="JUSTIFY">      (write line " Linetype   Align   Segs   Description")         :</P>
<P ALIGN="JUSTIFY">      (terpri)                                                      :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq cl (getvar "CELTYPE") f "  ")  ; Текущий тип линии,     :</P>
<P ALIGN="JUSTIFY">                                               ;  "регистр" флажка      :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Если текущий тип линии "BYLAYER", справься о текущем уровне    :</P>
<P ALIGN="JUSTIFY">       ; Провести линию и изменить "регистр" флажка с"" на "L"          :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">   (setq cl                                                         :</P>
<P ALIGN="JUSTIFY">      (cond ((= cl "BYBLOCK") "")                                   :</P>
<P ALIGN="JUSTIFY">            ((= cl "BYLAYER") (setq f "L ")                         :</P>
<P ALIGN="JUSTIFY">                (fld 6 (tblsearch "LAYER" (getvar "CLAYER"))))      :</P>
<P ALIGN="JUSTIFY">            (T cl)                                                  :</P>
<P ALIGN="JUSTIFY">       ))                                                               :</P>
<P ALIGN="JUSTIFY">   (setq x (tblnext "LTYPE" T))   <FONT FACE="Times New Roman">          ; Первый тип линии      :</font></P>
<P ALIGN="JUSTIFY">   (while x                                                         :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq lt (fld  2 x)                   ; Имя типа линии        :</P>
<P ALIGN="JUSTIFY">                d  (fld  3 x)                   ; Простое описание типа :</P>
</FONT><P ALIGN="JUSTIFY">      <FONT FACE="Times New Roman">                                          ; линии                 :</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">                a  (fld 72 x)                   ; Выравненный код       :</P>
<P ALIGN="JUSTIFY">                s  (fld 73 x)                   ; Длина каждого штриха  :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<P ALIGN="JUSTIFY">   (write line                                                      :</P>
<P ALIGN="JUSTIFY">      (strcat                                                       :</P>
<P ALIGN="JUSTIFY">         (if (=lt cl) f "  ")              <FONT FACE="Times New Roman"> ; Регистр флажка прими- :</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">                                                ;   тива линии          :</P>
<P ALIGN="JUSTIFY">         (strfill lt 12)                    ; Редактор имени        :</P>
<P ALIGN="JUSTIFY">                                                ;   уровня              :</P>
</FONT><P ALIGN="JUSTIFY">         (s<FONT FACE="Times New Roman">trfill (chr a) 7)                ;  Выравненный код      :</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">         (strfill (itoa s) 6)               ;   Длина черточки      :</P>
<P ALIGN="JUSTIFY">                                                ;  элементов            :</P>
<P ALIGN="JUSTIFY">         (substr d 1 30)                    ;   Описание типа линии :</P>
</FONT><P ALIGN="JUSTIFY">       ))                                                               :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (if (&gt; s 0) (progn                    ; Если любой отдельный     :</P>
<P ALIGN="JUSTIFY">                                             ;элемент,редактируйте его  :</P>
</FONT><P ALIGN="JUSTIFY">      (setq x (member<FONT FACE="Times New Roman"> (assoc 49 x) x))   ; Введите список каждого   :</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">                                             ; элемента                 :</P>
</FONT><P ALIGN="JUSTIFY">          (while x                                                  :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       (setq s (cdar x))               ; Введите длину штриха :</P>
</FONT><P ALIGN="JUSTIFY">             (write line                                            :</P>
<P ALIGN="JUSTIFY">                (strcat                                             :</P>
<P ALIGN="JUSTIFY">                   (strfill " " 27)                                 :</P>
<P ALIGN="JUSTIFY">                   (cond ((= s 0) "Dot")                            :</P>
<P ALIGN="JUSTIFY">                         ((&gt; s 0) (strcat "Pen down" (rtos s 2 4))) ;</P>
<P ALIGN="JUSTIFY">                         (T   (strcat "Pen up"   (rtos (abs s) 2:</P>
<P ALIGN="JUSTIFY">                         4)))                                       :</P>
<P ALIGN="JUSTIFY">                 )))                                                    :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">             (setq x (cdr x))                ; Введите следующий    :</P>
<P ALIGN="JUSTIFY">                                                 ;  элемент             :</P>
</FONT><P ALIGN="JUSTIFY">           )))                                                          :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       (setq x (tblnext "LTYPE"))            ; Введите следующий    :</P>
<P ALIGN="JUSTIFY">                                                 ;   тип линии          :</P>
</FONT><P ALIGN="JUSTIFY">       )                                                                :</P>
<P ALIGN="JUSTIFY">   (terpri)                                                         :</P>
<P ALIGN="JUSTIFY">    )                                                                   :</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I><FONT FACE="Arial">
<P ALIGN="JUSTIFY"><A NAME="_Toc465172788"><A NAME="_Ref465174284"><A NAME="_Toc465261032">Воображаемое 
  окошко (ZOOM Window)</A></A></A></P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Эта программа использует функции механизма доступа, который выполняет фантазию ZOOM Window ( масштаб в окошке), позволяющую вам установить триггер между перемещенным и измененным размером в боксе.:</P>
<P ALIGN="JUSTIFY">ZOOM Window подобен ZOOM Dynamic, исключает выполнение на текущем дисплее без ручной клавиатуры , кроме клавиш пробел ,  возврат и клавиши со стрелкой.</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (defun drawbox ()                          ; Вычерчивание бокса  :</P>
</FONT><P ALIGN="JUSTIFY">      (grdraw ll ul 1) (grdraw ul ur 1)                             :</P>
<P ALIGN="JUSTIFY">      (grdraw ur lr 1) (grdraw lr ll 1)                             :</P>
<P ALIGN="JUSTIFY">      (if (= mode 0) (cenx) (arrow)                                 :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (defun cenx ()                             ; Определение центра Х:</P>
</FONT><P ALIGN="JUSTIFY">      (grdraw x1 x2  1) (grdraw x3 x4 1)                            :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (defun arrow ()                            ; Вычерчивание стрелок:</P>
</FONT><P ALIGN="JUSTIFY">      (grdraw a1 a4 1)  (grdraw a2 a4 1)  (grdraw a3 a4 1)          :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (defun newbox ()                           ; Переопределение па- :</P>
<P ALIGN="JUSTIFY">                                                  ; раметров бокса  &amp;   :</P>
</FONT><P ALIGN="JUSTIFY">                                                  ; draw                :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq deltay (* deltax aspect))        ; Допускает , что del- :</P>
<P ALIGN="JUSTIFY">                                                 ; tax &amp; был центр      :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; Переустановка в более высокий уровень                       :</P>
</FONT><P ALIGN="JUSTIFY">      (setq xcen (car center) ycen (cadr center))                   :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; Понижение/повышение X/Y для бокса                           :                                   :</P>
</FONT><P ALIGN="JUSTIFY">      (setq lx (- xcen deltax) ux (+ xcen deltax))                  :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">      (setq ly (- ycen deltay) uy (+ ycen deltay))                  :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq ll (list lx ly) ul (list lx ly))   ; Углы бокса         :</P>
</FONT><P ALIGN="JUSTIFY">      (setq ur (list ux uy) lr (list ux ly))                        :                                                                         :     </P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; Повышение/понижение Y перекрестия &amp; стрелки                 :</P>
</FONT><P ALIGN="JUSTIFY">      (setq yp (+ ycen arm) ym (- ycen arm))                        :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">          ; Левый наклон стрелки </font>                                       :</P>
<P ALIGN="JUSTIFY">      (setq al (list (- ux arm) yp) a2 (list (-ux arm) ym))         :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq a3 (list (- ux arm arm) ycen))     ; Хвост стрелки      :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; Правый конец всех трех                                      :</P>
</FONT><P ALIGN="JUSTIFY">      (setq a4 (list ux ycen))                                      :</P>
<P ALIGN="JUSTIFY">      (setq x1 (list (- xcen arm) ym) x2 (list (+ xcen arm) yp))    :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; Концы по X                                                  :</P>
</FONT><P ALIGN="JUSTIFY">      (setq x3 (list (- xcen arm) yp) x4 (list (+ xcen arm) ym))    :</P>
<P ALIGN="JUSTIFY">      (drawbox)                                                     :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">      (defun C:ZW (/ arm aspect center deltax inp loop mode prev    :</P>
<P ALIGN="JUSTIFY">                        pt sourse)                                      :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">            <FONT FACE="Times New Roman"> ; Запуск на центр экрана                                   :</font></P>
<P ALIGN="JUSTIFY">         (setq center (getvar "VIEWCTR"))                           :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">             ; Попытка переместить курсор с центра</font>                      :</P>
<P ALIGN="JUSTIFY">         (setvar "LASTPOINT" (setq prev center))                    :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">         (setq aspect (/ (cadr (aetq aspect (getvar "SCREENSIZE"))) :</P>
<P ALIGN="JUSTIFY">            (car aspect)))                                          :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">             ; Использование 1/4 бокса экрана                           :</P>
</FONT><P ALIGN="JUSTIFY">         (setq deltax (* 0.25 (getvar "VIEWSIZE")))                 :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">             ; Первоначальный режим движения в боксе                    :</P>
</FONT><P ALIGN="JUSTIFY">         (setq arm (* 0.1 deltax) mode 0 loop T)                    :</P>
<P ALIGN="JUSTIFY">         (newbox)                                                   :</P>
<P ALIGN="JUSTIFY">         (while loop                                                :</P>
<P ALIGN="JUSTIFY">          <FONT FACE="Times New Roman">  (setq inp grread T))     ; Выход прослеженный           :</font></P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                ; Изолирование источника и # или точки                  :</P>
</FONT><P ALIGN="JUSTIFY">            (setq source (car inp) pt (cadr inp))                   :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">            (cond ((= source 3)      ; "Pick"(выбрать) клавишей?    :</P>
<P ALIGN="JUSTIFY">                     (cenx) (arrow)  ; Уничтожить Х &amp; начертить     :</P>
<P ALIGN="JUSTIFY">                                         ; или дефекты многочисленны    :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                         ; Триггер в режиме бокса                       :</P>
</FONT><P ALIGN="JUSTIFY">                     (setq mode (- 1 mode))                         :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                         ; Попытка  переместить курсор с центра         :</P>
</FONT><P ALIGN="JUSTIFY">                     (setvar "LASTPOINT" center))                   :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                  ((= source 5))     ; Выслеженная точка?           :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                         ; Если ее сдвинуть...                          :</P>
</FONT><P ALIGN="JUSTIFY">                     (if (or (/= (car  prev) (car pt))              :</P>
<P ALIGN="JUSTIFY">                             (/= (cadr prev) (cadr pt)))            :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                         ; Изменить или сдвинуть бокс                   :      </P>
</FONT><P ALIGN="JUSTIFY">                     (progn                                         :</P>
<P ALIGN="JUSTIFY">                         (if (= mode 0)                             :</P>
<P ALIGN="JUSTIFY">                            (setq center pt)                        :</P>
<P ALIGN="JUSTIFY">                            (setq deltax (+ deltax (- (car pt)      :</P>
<P ALIGN="JUSTIFY">                            (car prev)))))                          :</P>
<P ALIGN="JUSTIFY">                         (setq prev pt)                             :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                         (drawbox)        ; Удалить старый блок     :</P>
</FONT><P ALIGN="JUSTIFY">                                                                        :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                             ; Ввести новый центр/размер и чертеж       :</P>
</FONT><P ALIGN="JUSTIFY">                         (newbox)                                   :</P>
<P ALIGN="JUSTIFY">                        )))                                             :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">              ((or (and (= source 6) (= pt 0))  ;lst меню клавиш(CR):</P>
<P ALIGN="JUSTIFY">                   (and (= source 2)            ; или клавиатура и  :</P>
</FONT><P ALIGN="JUSTIFY">          <FONT FACE="Times New Roman">         (or (= pt 13) (= pt 32))))   ; CR или бланк?     :</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">                 (drawbox)                      ;Удалить старый бокс:</P>
</FONT><P ALIGN="JUSTIFY">                 (command "ZOOM" "W" ll ur)                         :</P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman">                 (setq loop nil))               ; Выход </font>            :</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">            (T                              ;Любая grread переменная:</P>
<P ALIGN="JUSTIFY">                 (drawbox)                      ;Удалить старый блок:</P>
<P ALIGN="JUSTIFY">                 (setq loop nil a " ^cancel ")) ; Выход             :</P>
</FONT><P ALIGN="JUSTIFY">              )                                                         :</P>
<P ALIGN="JUSTIFY">            )                                                           :</P>
<P ALIGN="JUSTIFY">       )                                                                :</P>
<P ALIGN="JUSTIFY">                                                                        :</P>
<P ALIGN="JUSTIFY">&nbsp;</P>
<B><I>
<P ALIGN="JUSTIFY"><A NAME="_Toc465172789"></A><A NAME="_Ref465174285"></A><A NAME="_Toc465261033"></A><FONT FACE="Arial"> 
  Idle ( работать вхолостую)</font></P>
</i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Наконец, это та программа , которая иллюстрирует функции прямого  вывода на экран, также как и использование функции " ERROR".</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">       ; Команда IDLE</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">   (defun "ERROR" (s)              ; Ошибка наверху (или CTRL C)</P>
</FONT><P ALIGN="JUSTIFY">      (redra<FONT FACE="Times New Roman">w)                     ; Перечерчивание на экране</font></P><FONT FACE="Times New Roman">
<P ALIGN="JUSTIFY">      (grtext)                     ; Повторный вызов меню/статус</P>
<P ALIGN="JUSTIFY">                                       ; текста на экране</P>
</FONT><P ALIGN="JUSTIFY">       )</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">   (defun C:IDLE ()</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq vc (getvar "viewctr")) ; Вызов центральной точки на</P>
<P ALIGN="JUSTIFY">                                       ; экран</P>
</FONT><P ALIGN="JUSTIFY">      (setq cx (car vc))</P>
<P ALIGN="JUSTIFY">      (setq cy (cadr vc))</P>
<P ALIGN="JUSTIFY">      (setq vc (/ (getvar "viewsize") 2))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (setq xmin (- cx vs))        ; Вычислить сторону квадрата</P>
</FONT><P ALIGN="JUSTIFY">      (setq xmax (+ cx vs))</P>
<P ALIGN="JUSTIFY">      (setq ymin (- cy vs))</P>
<P ALIGN="JUSTIFY">      (setq ymax (+ cy vs))</P>
<P ALIGN="JUSTIFY">      (setq xdir (/ vs 10) ydir xdir)</P>
<P ALIGN="JUSTIFY">      (setq cx (+ cx (* xdir 7)))</P>
<P ALIGN="JUSTIFY">      (setq cy (- cy (* ydir 3)))</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (grclear)                       ; Чистый графический экран</P>
</FONT><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; В статусе свободного участка</P>
</FONT><P ALIGN="JUSTIFY">      (grtext -1 "       That's entertainment!')       </P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; В координатах свободного участка</P>
</FONT><P ALIGN="JUSTIFY">      (grtext -2 "Press CANCEL to stop.")</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">          ; Набор начальной точки</P>
</FONT><P ALIGN="JUSTIFY">      (setq lp (list cx cy))</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">      (while t                    ; Цикл навсегда ( ....до CTRL C)</P>
<P ALIGN="JUSTIFY">         (setq nx (+ cx xdir))    ; Набор конечной координаты Х</P>
</FONT><P ALIGN="JUSTIFY">         (if (or (&gt; nx xmax) (&lt; nx xmin))</P>
<P ALIGN="JUSTIFY">            (progn</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">                (setq xdir (- xdir))    ; Соответствующий каталог Х</P>
</FONT><P ALIGN="JUSTIFY">                (setq nx cx)</P>
<P ALIGN="JUSTIFY">         )</P>
<P ALIGN="JUSTIFY">      )</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">  (setq ny (+ cy ydir))         ; Набор конечной Y координаты</P>
</FONT><P ALIGN="JUSTIFY">  (if (or (&gt; ny ymax) (&lt; ny ymin))</P>
<P ALIGN="JUSTIFY">      (progn</P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">         (setq ydir (- ydir))     ; Соответствующий каталог Y</P>
</FONT><P ALIGN="JUSTIFY">         (setq ny cy)</P>
<P ALIGN="JUSTIFY">          )</P>
<P ALIGN="JUSTIFY">       )</P>
<P ALIGN="JUSTIFY">   (setq cx nx cy ny)</P>
<P ALIGN="JUSTIFY">   (grdraw lp (<FONT FACE="Times New Roman">setq lp (list nx ny)) -1)     ; Вычерчивание с"XOR ink"</font></P>
<P ALIGN="JUSTIFY">    )</P>
<P ALIGN="JUSTIFY">  )</P>
<P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"></FONT>
<P ALIGN="JUSTIFY"></P>
<B><FONT FACE="Times New Roman" SIZE=4 COLOR="#000000">
<h2><A NAME="#3">СООБЩЕНИЯ ОБ ОШИБКАХ</A></h2>
</font></B><P ALIGN="JUSTIFY"></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Ниже приведен список сообщений об ошибках, которые вы время от времени увидите, когда вы пишете или выводите функции AutoLISPа. Если функция "ERROR" определена не пользователем ("ERROR" связана с nil), ошибка является стандартной акцией, тогда эти сообщения выводятся на экран дисплея в виде:</P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">error: message&#9;</font><FONT FACE="Courier New">ошибка:сообщение</font></P>
<FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">следом за прослеженной функцией. Если существует пользователь-определитель функции "ERROR", эта функция , называемая сообщением, пройдет только в качестве аргумента.</P>
</FONT><B><I><FONT FACE="Arial"><P ALIGN="JUSTIFY">Функции, отклоняемые AutoCADом</P>
</font></i></B><FONT FACE="Times New Roman"><P ALIGN="JUSTIFY">Аргументы проходящих в AutoCAD функций недействительны (таких, как функции  GETVAR "NOSUCH" или SETVAR с только читаемыми  системными переменными), или функция, переходящая сама в себя, недействительна в текущем контексте.</P>
</FONT><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad argument type </font>-<FONT FACE="Courier New"> </FONT><FONT FACE="Times New Roman">Функция снабжена некорректным типом аргумента. ( Например, вы не можете взять STRLEN как целое.)</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad association list</font><FONT FACE="Times New Roman"> - Список, объявленный функцией ASSOC, не состоит из "(нужная клавиша ) списков. </font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad entmod list</font><FONT FACE="Times New Roman"> - Аргумент, проходящий в функцию ENTMOD, имеет неподходящий вход списка данных (так же , как возвращаемый функцией ENTGET). </font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY"></P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad formal argument list </font>- <FONT FACE="Times New Roman">Когда вычислена эта функция, AutoLISP удалит список недействительных формальных аргументов. Возможно, что функция вовсе не является функцией , а в некоторой степени , список данных.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad function</font><FONT FACE="Times New Roman"> - Первый элемент в списке -недействительное имя функции. Возможно, что это имя переменной или число. Это сообщение также может показывать, что названная функция неподходяще определена - не забывайте возвращаемый список формальных аргументов.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad list</font><FONT FACE="Times New Roman"> - Неподходяще организован список, которым снабжена функция. Это может случиться,  если действительное число начинает десятичная точка; в таком случае вы должны использовать введение 0.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">Bad node ( плохой участок памяти node)</font><FONT FACE="Times New Roman"> - Недействителен пункт , встречаемый функцией TYPE.</font></P>
<FONT FACE="Courier New"><P ALIGN="JUSTIFY"></P>
</FONT><P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad node type in list</font><FONT FACE="Times New Roman"> - Недействителен пункт, встречаемый функцией FOREACH.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad point argument</font><FONT FACE="Times New Roman"> - Недостаточно определена точка (список двух действительных чисел) проходящая в функцию, ожидающую точку. Будьте внимательны, не начинайте действительное число с десятичной точки; в таком случае, вы должны использовать введение 0.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bad point value</font><FONT FACE="Times New Roman"> - То же самое, что выше.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">bool arg1 &lt;0 or &gt;15</font><FONT FACE="Times New Roman"> - Первый аргумент функции BOOLE (Булева функция) должно быть целое между 0 и 15.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">can't evaluate expression</font><FONT FACE="Times New Roman"> - Эта ошибка может быть вызвана неправильным местоположением десятичной точки и с другой стороны, недостаточно сформулированным выражением.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">console break</font><FONT FACE="Times New Roman"> - Пользователь ввел CTRL C , в то время, когда функция обрабатывалась.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">divide by zero</font><FONT FACE="Times New Roman"> - Деление на нуль не разрешается.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">extra right paren</font><FONT FACE="Times New Roman"> - Встретились одни или более лишние правые скобки.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">file not open</font><FONT FACE="Times New Roman"> - Описатель файла  для операции ввода-вывода (I/O) не такой , как у доступного файла.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">Function cancelled</font> <FONT FACE="Times New Roman">( снимаемая функция) - Пользователь нажал CTRL C в ответ на подсказку.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">function undefined for argument</font><FONT FACE="Times New Roman"> - Аргумента, обозначенного в функциях LOG или SQRT, нет в диапазоне.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">function undefined for real</font><FONT FACE="Times New Roman"> - Аргумент функции вместо целого числа обозначен действительным. Например, (LSH val 1.2)</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">improper argument</font><FONT FACE="Times New Roman"> - Аргумент в GCD отрицательное число или ноль.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">incorrect number of arguments to a function</font><FONT FACE="Times New Roman"> - Количество аргументов определяемой пользователем функции не соответствует количеству формальных аргументов, объявленных функцией DEFUN.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">insufficient node space</font><FONT FACE="Times New Roman"> - Недостаточен участок памяти node , для того чтобы вместить потребные действия. См. главу 6.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">insufficient string space</font><FONT FACE="Times New Roman"> - Недостаточен участок памяти heap , чтобы вместить строку текста. См. главу 6.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">invalid argument</font><FONT FACE="Times New Roman"> - Неправильный тип аргумента или аргумент вне диапазона.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">invalid character</font><FONT FACE="Times New Roman"> - Выражение содержит неверный знак.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">invalid dotted pair</font><FONT FACE="Times New Roman"> - Точечные пары - это списки, содержащие два элемента, разделенные конструкцией "space-period-space". Вы можете получить это сообщение об ошибке , если вы начинаете действительное число с десятичной точки; в таком случае вы должны использовать введение 0.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">LISPSTACK overflow</font><FONT FACE="Times New Roman"> (переполнение стека) - Стек AutoLISPа переполнен. Это происходит из-за чрезмерного повторения функции или очень больших списков аргументов функции. Попытайтесь увеличить среду LISPSTACK для переменных.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">misplaced dot</font><FONT FACE="Times New Roman"> - Это может иметь место , если действительное число начинает десятичная точка; в таком случае вы должны использовать введение 0 .</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">null function</font><FONT FACE="Times New Roman"> - Была сделана попытка вычислить функцию , которая имеет нулевой определитель.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">quit exit abort</font><FONT FACE="Times New Roman">  - Это результат вызова функций QUIT или EXIT. Эти функции сейчас не используются в AutoLISPе.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">too few arguments</font><FONT FACE="Times New Roman"> - Слишком мало аргументов объявлено во встроенной функции</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">too many arguments</font><FONT FACE="Times New Roman"> - Слишком много аргументов объявлено во встроенной функции.</font></P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY"><FONT FACE="Courier New">unexpected signal nnn</font><FONT FACE="Times New Roman"> -( Только для системы UNIX) От работающей системы получен неожиданный сигнал.</font></P></BODY>
</HTML>