<HEAD>
 <META HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=Windows-1251">
	<TITLE>СПРАВОЧНОЕ РУКОВОДСТВО ПО JAVASCRIPT</TITLE>
<script>
</script>
</HEAD>
<BODY text="Black" link="#336699" vlink="#6699cc" alink=" #ff6600">
<h1>Объектная модель JavaScript</h1> 
<p>
<font color="red"><i>JavaScript</i></font> основан на простом объектно-ориентированном примере. Объект - это конструкция со свойствоми, которые являются переменными <font color="red"><i>JavaScript</i></font>. Свойства могут быть другими объектами. Функции, связанные с объектом известны как <i>методы</i> объекта. 
<P>
 В дополнение к объектам, которые сформированы в Navigator client 
и LiveWire server, вы можете определять ваши собственные объекты. 
<UL>
 <LI> <a href="#objprop">Объекты и Свойства</a> 
<LI> <a href="#funcmeth">Функции и Методы</a>
<LI> <a href="#newobj">Создание Новых Объектов</a></LI> 
</UL>
<a name="objprop"> 
<h2> Объекты и Свойства </h2> 
<p>
Объект <font color="red"><i>JavaScript</i></font> имеет свойства ассоциированные с ним. Вы обращаетесь к свойствам объекта следующей простой системой обозначений: 
<table><tr><td bgcolor=aqua><pre>  
objectName.propertyName
 </pre></table> 
<p>
 И имя объекта и имя свойства чувствительны к регистру. Вы определяете свойства,  приписывая значение. Например, пусть существует объект, с именем <i>myCar</i> (мы обсудим, как создавать объекты позже - теперь, только принимаем, что  объект уже существует). Вы можете дать свойства, именованные <b> make </b>, <b> model </b>, и <b> year </b> следующим образом: 
<table><tr><td bgcolor=aqua><pre>  
myCar.make = "Ford"
myCar.model = "Mustang"
myCar.year = 69;
 </pre></table> 
<P>
 Вы можете также обратиться к этим свойствам, используя систему обозначений таблицы следующим образом: 
<table><tr><td bgcolor=aqua><PRE>  
mycar["make"] = "Ford
myCar["model"] = "Mustang"
myCar["year"] = 69;
 </PRE> </table>
<p>
Этот тип таблицы известен как ассоциативная таблица, потому что каждый элемент индекса также связан со значением строки. Чтобы пояснять, как это делается, следующая функция показывает свойство объекта, когда вы проходите объект и имя объекта как аргументы функции: 
<table><tr><td bgcolor=aqua>
<prefunction show_props(obj, obj_name) {
    var result = ""
    for (var i in obj)
        result += obj_name + "." + i + " = " + obj[i] + "\n"
    return result;
} 
 </pre> </table>
<p>
Так, обращение к функции <tt>show_props(myCar, "myCar") </tt> возвращает  следующее: 
<table><tr><td bgcolor=aqua><pre>
myCar.make = Ford
myCar.model = Mustang
myCar.year = 67
</pre> </table>
<P>
 Вы можете также определять свойства, используя порядковые числа, например: 
<table><tr><td bgcolor=aqua><PRE>  
temp[0] = 34
temp[1] = 42
temp[2] = 56
 </PRE> </table>
Эти утверждения создают три свойства объекта <i>temp</i>, и вы должны обращаться к этим свойствам как temp[<i>i</i>], где <i>i</i> - целое число между 0 и 2.
<!--------------------------------------------------------------------------------------->
 <a name="funcmeth">
<h2> Функции и Методы</h2> 
<P>
Функции - один из фундаментальных встроенных блоков в <font color="red"><i>JavaScript</i></font>. Функция - <font color="red"><i>JavaScript </i></font> процедура - набор утверждений, которые выполняют определенную задачу. 
<P>
 Определение функции состоит из ключевого слова <b>function </b>, сопровождаемого 
<UL>
 <LI>Именем функции 
<LI> Списком аргументов функции, приложенной в круглых скобках, и отделяемые запятыми 
<LI> <font color="red"><i>JavaScript</i></font> утверждениями, которые определяют функцию, приложенные в фигурных скобках, {...} 
</UL>
<P>
Вы можете использовать любые функции, определенные в текущей странице. Лучше всего определять все ваши функции в <code>HEAD</code> страницы. Когда пользователь загружает страницу, сначала загружаются функции. 
<P>
 Утверждения в функциях могут включать другие обращения к функции. 
<P>
 Например, есть функция с именем pretty_print: 
<table><tr><td bgcolor=aqua><XMP> 
function pretty_print(string) { document.write("
" + string) }
</XMP></table>
<P>
 Эта функция принимает строку как аргумент, прибавляет некоторые теге HTML, используя оператор суммы (+), затем показывает результат в текущем документу. 
<P>
 Определение функции не выполняет ее. Для этого вы должны <i>вызвать</i> функцию, чтобы выполнить ее. Например, вы можете вызывать функцию pretty_print следующим образом: 
<table><tr><td bgcolor=aqua><XMP>
 <SCRIPT>
pretty_print("This is some text to display")
</SCRIPT>
 </XMP></table>
<P>
 Аргументы функции не ограничены только строками и числами. 
<P>
 Аргументы функции сохраняются в таблице. Внутри функции, вы можете адресовать параметры следующим образом: 
<pre>  <i>
functionName</i>.arguments <i>[i]</i>
 </pre> 
Где <i>functionName</i> - имя функции, и <i>i</i> - порядковое число аргумента, начинающегося с нуля. Так, первый аргумент в функции, с именем myfunc, будет myfunc.arguments [0]. Общее число аргументов обозначено переменным arguments.length. 
<P>
 Функция может даже быть рекурсивной, то есть она может вызывать себя. Например, существует функция, которая вычисляет факториалы: 
<table><tr><td bgcolor=aqua><PRE>  
function factorial(n) {
  if ((n == 0) || (n == 1))
    return 1
  else {
    result = (n * factorial(n-1) )
    return result
  }
}
 </PRE> </table>
<P>
 Вы можете показывать факториалы от одного до пять следующим образом: 
<table><tr><td bgcolor=aqua><PRE>  
for (x = 0; x < 5; x++) {
   document.write(x, " factorial is ", factorial(x))
   document.write("
")
} 
</PRE></table>
<P>
 Результаты будут бы следующие:
 <BR>
факториал нуля - 1 <BR>
факториал единицы- 1 <BR>
факториал двойки - 2 <BR>
факториал тройки - 6 <BR>
факториал четверки - 24 <BR>
факториала пятерки - 120
<h3> Функции с Переменными Числовыми Аргументами</h3> 
<P>
 Вы можете вызывать,  функция с большим количеством аргументов чем она формально объявлена, используя массив <I>arguments </I>. Это часто полезно тогда, когда вы не знаете заранее, сколько аргументов будут в функции. Вы можете использовать arguments.length, чтобы определить  число аргументов в функции,  и затем обращаться к каждому аргументу, используя массив <I>arguments </I>.
<P>
Например, рассмотрим функцию, определенную, чтобы создать списки HTML. 
Единственый формальный аргумент функции - строка, которая является "U", если список неупорядочен  или "O", если список упорядочен (пронумерован). Функция определена следующим образом:
<table><tr><td bgcolor=aqua><XMP>
function list(type) {
 document.write("<" + type + "L") 
//начинается список 
for (var i = 1; i < list.arguments.length; i++) // Повторить через аргументы document.write("" + list.arguments[i])
 document.write("</" + type + "L") 
// заканчивается список
 }
</XMP></table>
<P>
 
Вы можете проходить любое число аргументов этой функции, и затем показывать каждый аргумент как каждый отдельный пункт в обозначенном типе списка. Например, следующий запрос на функцию:
<table><tr><td bgcolor=aqua><PRE>  
list("o", "one", 1967, "three", "etc, et 
<ol>
<li> one
<li> 1967
<li> three
<li>etc, etc ...
</ol> 
</pre></table>
<h3> Определение Методов</h3> 
<p>
<i>Метод</i> - функция, связанная с объектом. Вы определяете метод таким же образом, так как вы определяете стандартную функцию. Затем, используйте следующий синтаксис, чтобы связать функцию с существующим бъектом:
<table><tr><td bgcolor=aqua><pre> <i>object.methodname = function_name</i> </pre> </table>
Где <i> object </i> - существующий объект, <i>methodname</i> - имя, которое вы присваиваете методу, и <i>function_name</i> - имя функции. 
<p>
 Вы можете вызывать метод в контексте объекта следующим образом: 
<table><tr><td bgcolor=aqua><pre> object.methodname (params); </pre></table> 
<h3> Использование this для Ссылок Объекта</h3> 
<p>
<font color="red"><i> JavaScript</i></font> имеет специальное ключевое слово, <b>this</b>, которое вы можете использовать, чтобы обращаться к текущему объекту. Например, пусть у вас есть функция с именем  <i> validate </i>, которая проверяет правильность свойства значения объекта, данного объект, и high и low значения: 
<table><tr><td bgcolor=aqua><pre> 
function validate(obj, lowval, hival) {
   if ((obj.value < lowval) || (obj.value > hival))
      alert("Invalid Value!")
}
 </pre> </table>
<p>
 Вы можете вызывать<i> validate </i> в каждом элементе формы обработчика событий onChange, используя <b>this</b>, как показано в следующем примере: 
<table><tr><td bgcolor=aqua><XMP>
<INPUT TYPE = "text" 
       NAME = "age"
       SIZE = 3
       onChange="validate(this, 18, 99)">
 </XMP></table>
<p>
Вообще, метод <b>this</b> обращается к вызывающему объекту.  
<a name="newobj">
<h2> Создание Новых Объектов</h2> 
<p>
 И клиент и сервер <font color="red"><i>JavaScript</i></font> имеют строки предопределенных объектов. Кроме того, вы можете создавать ваши собственные объекты. Создание вашего собственного объекта требует двух шагов: 
<ul>
 <li> Определить тип объекта,  написанной функции. 
<li> Создать образец объекта с <b>new</b>. 
</ul>
<p>
 Чтобы определять тип объекта, создайте функцию для типа объекта, которая определяет его имя, и его свойства и методы. Например, пусть вы хотите создавать тип объекта для автомобилей. Вы хотите этот тип объектов, который будет назван <i>car</i>, и Вы хотите, чтобы он имел свойства для make, model, year, и color. Чтобы сделать это, вы должны написать следующую функцию: 
<table><tr><td bgcolor=aqua><pre> function car(make, model, year) {
   this.make = make;
   this.model = model;
   this.year = year;
}
 </pre> </table>
<p>
Замечание, используйте <b>this</b>, чтобы присвоить значения свойствам объекта, основанные на значениях функции. 
<p>
 Теперь вы можете создавать объект, с именем <i>mycar</i> следующим образом: 
<table><tr><td bgcolor=aqua><pre>
 mycar = new car("Eagle", "Talon TSi", 1993);
 </pre> </table>
<p>
 Это утверждение создает <i>mycar</i> и присваивает ему указанные значения для его свойств. Затем значение <code>mycar.make</code> - строка "Eagle", <code>mycar.year</code> - целое число 1993, и так далее. 
<p>
 Вы можете создавать любое число объектов <i>car</i> запрашивая  к <b>new</b>.  Например, 
<table><tr><td bgcolor=aqua><pre> 
kenscar = new car("Nissan", "300ZX", 1992)
 </pre> </table>
<p>
 Объект может иметь свойство, которое является самостоятельным другим объектом. Например, пусть вы определили объект с именем <i> person</i> следующим образом: 
<table><tr><td bgcolor=aqua><pre> 
function person(name, age, sex) {
   this.name = name;
   this.age = age;
   this.sex = sex;
}
 </pre> </table>
<p>
 И затем подтверждаете два новых объектов <i> person</i> следующим образом: 
<table><tr><td bgcolor=aqua><pre> 
rand = new person("Rand McNally", 33, "M")
ken = new person("Ken Jones", 39, "M")
 </pre> </table>
<p>
 Затем вы можете перезаписать определение <i>car</i>, чтобы включить свойство владельца, которое берет объект <i> person</i>, следующим образом: 
<table><tr><td bgcolor=aqua><pre>
function car(make, model, year, owner) {
   this.make = make;
   this.model = model;
   this.year = year;
   this.owner = owner;
}
 </pre> </table>
<p>
Затем вы используете следующее: 
<table><tr><td bgcolor=aqua><pre>
car1 = new car("Eagle", "Talon TSi", 1993, rand);
car2 = new car("Nissan", "300ZX", 1992, ken)
 </pre> </table>
<p>
Заметим, что вместо прохождения строкового литерала или целого числа вычисляет при создании новых объектов, вышеупомянутый ход утверждений объектов rand и ken как аргументов владельцев. Затем, если вы хотите выяснять имя владельца car2, вы можете обращаться к следующему свойству: 
<table><tr><td bgcolor=aqua><pre> car2.owner.name </pre> </table>
<p>
 Заметьте, что вы можете всегда прибавлять свойства к предопределенному объекту. Например, утверждение: 
<table><tr><td bgcolor=aqua><pre> car1.color = "black"</pre> </table>
Прибавляет свойство color к car1, и присваивает ему значение " black". Однако, это не воздействует на любые другие объекты. Чтобы прибавить новое свойство ко всем объектам того же самого типа, вы должны прибавить свойство к определению типа объекта <i>car</i>. 
<h3> Определение Методов</h3> 
<p>
 Вы можете определять методы для типа объекта включением определение метода на определении типа объекта. Например, пусть у вас есть набор файлов изображений GIF, и вы хотите определить метод, который показывает информацию для car, наряду с соответствующим изображением. Вы можете определить функцию типа: 
<table><tr><td bgcolor=aqua><pre> 
function displayCar() {
   var result = "A Beautiful " + this.year
                + " " + this.make + " " + this.model;
   pretty_print(result)
}
 </pre> </table>
Где <i>pretty_print</i> - предопределенная функция, которая показывает строку. Используйте this, чтобы обратиться к объекту,  который принадлежит методу. 
<p>
 Вы можете делать функцию методом из <i>car</i>,  прибавляя утверждение 
<pre> This.displayCar = displayCar;</pre> 
к определению объекта. Так, полное определение <i>car</i> теперь выглядит так: 
<table><tr><td bgcolor=aqua><pre>
function car(make, model, year, owner) {
   this.make = make;
   this.model = model;
   this.year = year;
   this.owner = owner;
   this.displayCar = displayCar;
} </pre> </table>
<p> Вы можете вызывать этот новый метод следующим образом: 
<table><tr><td bgcolor=aqua><pre> 
car1.displayCar () 
car2.displayCar ()
 </pre> </table>
Это будет выглядеть подобно следующему выводу: 
<p><hr >
A Beautiful 1993 Eagle Talon TSi
<p>
 <hr>
A Beautiful 1992 Nissan 300ZX
<hr align=center width=250>
</body>
 </HTML>
